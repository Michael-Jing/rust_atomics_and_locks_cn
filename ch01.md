# 第一章 Rust 并发基础

在多核处理器普及之前很久，操作系统就允许一台计算机同时运行多个程序。这是通过快速切换进程实现的，允许每个进程依次稍微进展一点。如今，我们的计算机、甚至我们的手机和手表几乎都配备了多核处理器，能够真正并行执行多个进程。

操作系统尽可能地隔离进程，允许一个程序进行操作，而完全不知道其他进程在做什么。例如，一个进程通常无法访问另一个进程的内存，或以任何方式与之通信，除非首先请求操作系统的内核。

然而，一个程序可以产生额外的执行线程，作为同一进程的一部分。同一进程内的线程彼此不隔离。线程共享内存，并可以通过该内存相互作用。

本章将解释如何在 Rust 中产生线程，以及围绕它们的所有基本概念，例如如何安全地在多个线程之间共享数据。本章解释的概念是本书其余部分的基础。

如果您已经熟悉 Rust 的这些部分，请随时跳过。然而，在您继续阅读下一章之前，请确保您对线程、内部可变性、Send 和 Sync 有良好的理解，并知道互斥锁、条件变量和线程停车是什么。

Rust 中的线程

每个程序都以一个线程开始：主线程。这个线程将执行您的主函数，并且可以在必要时产生更多线程。

在 Rust 中，使用标准库中的 std::thread::spawn 函数产生新线程。它接受单个参数：新线程将执行的函数。一旦此函数返回，线程停止。

让我们看一个例子：

```rust
use std::thread;

fn main() {
    thread::spawn(f);
    thread::spawn(f);

    println!("Hello from the main thread.");
}

fn f() {
    println!("Hello from another thread!");

    let id = thread::current().id();
    println!("This is my thread id: {id:?}");
}
```
我们产生了两个将执行 f 作为它们的主函数的线程。这两个线程都将打印一条消息并显示它们的线程 id，而主线程也将打印它自己的消息。

线程 ID

Rust 标准库为每个线程分配了一个唯一标识符。此标识符可以通过 Thread::id() 访问，其类型为 ThreadId。除了复制它和检查相等性之外，您不能对 ThreadId 做太多事情。这些 ID 不保证连续分配，只保证每个线程都不同。

如果您多次运行上面的示例程序，您可能会注意到每次运行的输出都有所不同。这是我在一次特定运行中得到的输出：

```
Hello from the main thread.
Hello from another thread!
This is my thread id:
```
令人惊讶的是，部分输出似乎丢失了。

这里发生的是主线程在新产生的线程完成执行它们的函数之前完成了 main 函数的执行。

从 main 返回将退出整个程序，即使其他线程仍在运行。

在这个特定的例子中，一个新产生的线程刚好有足够的时间到达第二条消息的一半，然后程序被主线程关闭了。

如果我们想确保在从 main 返回之前线程完成，我们可以通过加入它们来等待它们。为此，我们必须使用 spawn 函数返回的 JoinHandle：

```rust
fn main() {
    let t1 = thread::spawn(f);
    let t2

 = thread::spawn(f);

    println!("Hello from the main thread.");

    t1.join().unwrap();
    t2.join().unwrap();
}
```
.join() 方法等待线程执行完毕并返回一个 std::thread::Result。如果线程因为 panic 而没有成功完成其函数，这将包含 panic 消息。我们可以尝试处理那种情况，或者只是调用 .unwrap() 在加入 panic 的线程时 panic。

运行这个版本的我们的程序将不再导致截断的输出：

```
Hello from the main thread.
Hello from another thread!
This is my thread id: ThreadId(3)
Hello from another thread!
This is my thread id: ThreadId(2)
```
唯一仍然在运行之间变化的是消息打印的顺序：

```
Hello from the main thread.
Hello from another thread!
Hello from another thread!
This is my thread id: ThreadId(2)
This is my thread id: ThreadId(3)
```
输出锁定

println 宏使用 std::io::Stdout::lock() 确保其输出不会被中断。一个 println!() 表达式将等待任何并发运行的完成后再写入任何输出。如果不是这样，我们可能得到更多交错的输出，例如：

```
Hello fromHello from another thread!
 another This is my threthreadHello fromthread id: ThreadId!
( the main thread.
2)This is my thread
id: ThreadId(3)
```
而不是将函数的名称传递给 std::thread::spawn，如我们上面的例子所示，更常见的是传递一个闭包给它。这允许我们捕获值以移动到新线程：

```rust
let numbers = vec![1, 2, 3];

thread::spawn(move || {
    for n in &numbers {
        println!("{n}");
    }
}).join().unwrap();
```
这里，numbers 的所有权被转移到新产生的线程，因为我们使用了一个 move 闭包。如果我们没有使用 move 关键字，闭包将通过引用捕获 numbers。这将导致编译器错误，因为新线程可能比该变量存在的时间更长。

由于线程可能运行到程序执行的最后，spawn 函数在其参数类型上有一个 'static 生命周期约束。换句话说，它只接受可以永远保留的函数。一个通过引用捕获局部变量的闭包可能无法永远保留，因为那个引用在局部变量不存在的那一刻变得无效。

从线程中获取返回值是通过从闭包返回它来完成的。这个返回值可以从 join 方法返回的 Result 中获得：

```rust
let numbers = Vec::from_iter(0..=1000);

let t = thread::spawn(move || {
    let len = numbers.len();
    let sum = numbers.iter().sum::<usize>();
    sum / len  1
});

let average = t.join().unwrap();  2

println!("average: {average}");
```
这里，线程的闭包返回的值（1）通过 join 方法（2）发送回主线程。

如果 numbers 是空的，线程会在尝试除以零时 panic（1），join 将返回那个 panic 消息，导致主线程也因为 unwrap（2）而 panic。

线程构建器

std::thread::spawn 函数实际上只是 std::thread::Builder::new().spawn().unwrap() 的便捷简写。

std::thread::Builder 允许您在产生新线程之前为其设置一些设置。您可以使用它来为新线程配置堆栈大小，并为新线程命名。线程的名称通过 std::thread::current().name() 可用，将在 panic 消息中使用，并在大多数平台上的监控和调试工具中可见。

此外，Builder 的 spawn 函数返回一个 std::io::Result，允许您处理产生新线程失败的情况。如果操作系统耗尽内存，或者对您的程序应用了资源限制，这可能发生。std

::thread::spawn 函数如果无法产生新线程就会 panic。

作用域线程

如果我们确定产生的线程肯定不会超出某个范围的生命周期，那么该线程可以安全地借用不会永远存在的东西，如局部变量，只要它们超出该范围即可。

Rust 标准库提供了 std::thread::scope 函数来产生这样的作用域线程。它允许我们产生线程，这些线程不能超出我们传递给该函数的闭包的范围，使得可以安全地借用局部变量。

最好通过一个例子来展示它是如何工作的：

```rust
let numbers = vec![1, 2, 3];

thread::scope(|s| {  1
    s.spawn(|| {  2
        println!("length: {}", numbers.len());
    });
    s.spawn(|| {  2
        for n in &numbers {
            println!("{n}");
        }
    });
});  3
```
1	
我们用一个闭包调用 std::thread::scope 函数。我们的闭包直接执行并获得一个参数，s，代表范围。

2	
我们使用 s 来产生线程。闭包可以借用像 numbers 这样的局部变量。

3	
当范围结束时，所有尚未加入的线程都会自动加入。

这种模式保证了在范围中产生的任何线程都不能超出范围。因为那样，这种作用域产生方法不对其参数类型有 'static 约束，允许我们引用任何只要它们超出范围即可，例如 numbers。

在上面的例子中，两个新线程都在并发访问 numbers。这是可以的，因为它们中的任何一个（或主线程）都没有修改它。如果我们要更改第一个线程以修改 numbers，如下所示，编译器将不允许我们产生另一个也使用 numbers 的线程：

```rust
let mut numbers = vec![1, 2, 3];

thread::scope(|s| {
    s.spawn(|| {
        numbers.push(1);
    });
    s.spawn(|| {
        numbers.push(2); // Error!
    });
});
```
具体的错误消息取决于 Rust 编译器的版本，因为它经常改进以产生更好的诊断，但尝试编译上述代码将导致类似这样的东西：

```
error[E0499]: cannot borrow `numbers` as mutable more than once at a time
 --> example.rs:7:13
  |
4 |     s.spawn(|| {
  |             -- first mutable borrow occurs here
5 |         numbers.push(1);
  |         ------- first borrow occurs due to use of `numbers` in closure
  |
7 |     s.spawn(|| {
  |             ^^ second mutable borrow occurs here
8 |         numbers.push(2);
  |         ------- second borrow occurs due to use of `numbers` in closure
```
泄漏末日

在 Rust 1.0 之前，标准库有一个名为 std::thread::scoped 的函数，它会直接产生一个线程，就像 std::thread::spawn 一样。它允许非 'static 捕获，因为它返回的不是 JoinHandle，而是 JoinGuard，当丢弃时会加入线程。任何借用的数据只需要比这个 JoinGuard 存活更久。

就在 Rust 1.0 发布前不久，人们慢慢意识到不可能保证某些东西会被丢弃。有许多方法，例如创建循环引用的节点，可以使某些东西被忘记，或泄漏，而不被丢弃。

最终，在一些人称之为 "泄漏末日" 的事情中，得出的结论是，一个（安全的）接口的设计不能

依赖于假设对象总是在它们的生命周期结束时被丢弃的假设。泄漏一个对象可能合理地导致泄漏更多对象（例如，泄漏一个 Vec 也会泄漏其元素），但它可能不会导致未定义行为。因为这个结论，std::thread::scoped 被认为不再安全，被从标准库中移除。此外，std::mem::forget 从一个不安全函数升级为一个安全函数，以强调忘记（或泄漏）始终是一种可能性。

只有在 Rust 1.63 之后，一个新的 std::thread::scope 函数被添加，它有一个不依赖于 Drop 来确保正确性的新设计。

共享所有权和引用计数

到目前为止，我们已经看到了使用 move 闭包将所有权转移到线程（"Rust 中的线程"）和从生命周期更长的父线程借用数据（"作用域线程"）。当在两个线程之间共享数据时，没有一个线程可以保证比另一个线程活得更久，它们都不能拥有那些数据。任何在它们之间共享的数据都需要活得和最长寿命的线程一样长。

静态变量

创建不由单个线程拥有的东西的几种方法中，最简单的一种是静态值，它是由整个程序"拥有"的，而不是由单个线程拥有。在下面的例子中，两个线程都可以访问 X，但它们都不拥有它：

```rust
static X: [i32; 3] = [1, 2, 3];

thread::spawn(|| dbg!(&X));
thread::spawn(|| dbg!(&X));
```
一个静态项有一个常量初始化器，永远不会被丢弃，并且在程序的 main 函数甚至开始之前就已经存在。每个线程都可以借用它，因为它保证总是存在。

泄漏

通过泄漏分配来共享所有权的另一种方法。使用 Box::leak，可以放弃对 Box 的所有权，承诺永远不会丢弃它。从那时起，Box 将永远存在，没有所有者，允许任何线程在程序运行的整个时间里借用它。

```rust
let x: &'static [i32; 3] = Box::leak(Box::new([1, 2, 3]));

thread::spawn(move || dbg!(x));
thread::spawn(move || dbg!(x));
```
move 闭包可能看起来像我们将所有权移动到线程中，但仔细看 x 的类型会发现我们只是给线程提供了对数据的引用。

引用是 Copy 的，意味着当你"移动"它们时，原始的还在那里，就像一个整数或布尔值一样。

注意 'static 生命周期并不意味着值从程序开始时就存在，而只是意味着它活到程序结束。过去根本不相关。

泄漏 Box 的缺点是我们正在泄漏内存。我们分配了一些东西，但从未丢弃和释放它。如果这只发生有限的次数，这是可以的。但如果我们继续这样做，程序将慢慢耗尽内存。

引用计数

为了确保共享数据被丢弃和释放，我们不能完全放弃它的所有权。相反，我们可以共享所有权。通过跟踪所有者的数量，我们可以确保值只在没有所有者时被丢弃。

Rust 标准库通过 std::rc::Rc 类型提供了这个功能，简

称为"引用计数"。它与 Box 非常相似，除了克隆它不会分配任何新的东西，而是增加存储在包含值旁边的计数器。原始的和克隆的 Rc 都引用同一个分配；它们共享所有权。

```rust
use std::rc::Rc;

let a = Rc::new([1, 2, 3]);
let b = a.clone();

assert_eq!(a.as_ptr(), b.as_ptr()); // Same allocation!
```
丢弃一个 Rc 将递减计数器。只有最后一个 Rc，看到计数器降到零，将是丢弃和释放包含数据的那个。

如果我们试图将一个 Rc 发送到另一个线程，然而，我们会遇到以下编译器错误：

```
error[E0277]: `Rc` cannot be sent between threads safely
    |
8   |     thread::spawn(move || dbg!(b));
    |                   ^^^^^^^^^^^^^^^
```
事实证明，Rc 不是线程安全的（更多关于这个在"线程安全：Send 和 Sync"）。如果多个线程有一个 Rc 到同一个分配，它们可能会同时尝试修改引用计数器，这可能会导致不可预测的结果。

相反，我们可以使用 std::sync::Arc，代表"原子引用计数"。它与 Rc 完全相同，除了它保证对引用计数器的修改是不可分割的原子操作，使其可以安全地与多个线程一起使用。（更多关于这个在第 2 章。）

```rust
use std::sync::Arc;

let a = Arc::new([1, 2, 3]);  1
let b = a.clone();  2

thread::spawn(move || dbg!(a));  3
thread::spawn(move || dbg!(b));  3
```
1	
我们将一个数组放在一个新的分配中，连同一个引用计数器，它从一开始。

2	
克隆 Arc 将引用计数增加到两个，并为我们提供第二个 Arc 到同一个分配。

3	
两个线程通过它们各自的 Arc 访问共享数组。当它们丢弃它们的 Arc 时，都会递减引用计数器。最后一个丢弃其 Arc 的线程将看到计数器降到零，并将是丢弃和释放数组的那个。

命名克隆

不得不为每个 Arc 的克隆赋予不同的名称可能会迅速使代码变得杂乱和难以跟踪。虽然每个 Arc 的克隆是一个单独的对象，但每个克隆代表同一个共享值，这并不是通过为每个人命名不同的名称来很好地反映的。

Rust 允许（并鼓励）您通过用相同的名称定义一个新变量来遮蔽变量。如果您在同一个范围内这样做，原始变量就不能再被命名了。但是通过打开一个新的范围，像 let a = a.clone(); 这样的语句可以用来在该范围内重用相同的名称，同时在范围外保留原始变量。

通过在新的范围内包裹一个闭包（使用 {}），我们可以在将变量移动到闭包中之前克隆它们，而无需重命名它们。

```rust
let a = Arc::new([1, 2, 3]);

let b = a.clone();

thread::spawn(move || {
    dbg!(b);
});

dbg!(a);
```
Arc 的克隆在同一个范围内。每个线程都有自己的克隆，但名称不同。

```rust
let a = Arc::new([1, 2, 

3]);

thread::spawn({
    let a = a.clone();
    move || {
        dbg!(a);
    }
});

dbg!(a);
```
Arc 的克隆在不同的范围内。我们可以在每个线程中使用相同的名称。

因为所有权是共享的，引用计数指针（Rc<T> 和 Arc<T>）有与共享引用（&T）相同的限制。它们不允许您修改它们包含的值，因为该值可能同时被其他代码借用。

例如，如果我们试图对 Arc<[i32]> 中的整数切片进行排序，编译器会阻止我们这样做，并告诉我们我们不允许修改数据：

```
error[E0596]: cannot borrow data in an `Arc` as mutable
  |
6 |     a.sort();
  |     ^^^^^^^^
```
借用和数据竞争

在 Rust 中，值可以以两种方式被借用：

不可变借用
用 & 借用某物给出一个不可变引用。这样的引用可以被复制。它引用的数据的访问在所有这样的引用的副本之间共享。正如名称所暗示的，编译器通常不允许您通过这样的引用修改某些东西，因为这可能会影响当前借用相同数据的其他代码。

可变借用
用 &mut 借用某物给出一个可变引用。一个可变借用保证它是该数据的唯一活动借用。这确保了修改数据不会改变其他代码当前正在查看的任何东西。

这两个概念一起完全防止了数据竞争：一个线程正在修改数据，而另一个线程并发访问它的情况。数据竞争通常是未定义行为，这意味着编译器不需要考虑这些情况。它将简单地假设它们不发生。

为了澄清这意味着什么，让我们看一个例子，编译器可以使用借用规则做出有用假设的例子：

```rust
fn f(a: &i32, b: &mut i32) {
    let before = *a;
    *b += 1;
    let after = *a;
    if before != after {
        x(); // never happens
    }
}
```
在这里，我们得到一个整数的不可变引用，并在增加 b 引用的整数之前和之后存储整数的值。编译器可以自由假设关于借用和数据竞争的基本规则得到了维护，这意味着 b 不可能引用 a 引用的同一个整数。事实上，程序中的任何东西都不能在 a 借用它时可变地借用 a 引用的整数。因此，编译器可以很容易地得出 *a 不会改变，if 语句的条件永远不会为真，并且可以完全从程序中删除对 x 的调用作为优化。

除了使用不安全块来禁用一些编译器的安全检查之外，不可能编写违反编译器假设的 Rust 程序。

未定义行为

像 C、C++ 和 Rust 这样的语言有一组需要遵循的规则，以避免所谓的未定义行为。例如，Rust 的规则之一是永远不可能有多于一个对象的可变引用。

在 Rust 中，只有在使用不安全代码时才可能违反这些规则。"不安全"并不意味着代码是不正确的或永远不安全使用的，而是意味着编译器不会为您验证代码是安全的。如果代码确实违反了这些规则，

它就被称为不健全的。

编译器被允许假设，无需检查，这些规则永远不会被打破。当被打破时，这将导致所谓的未定义行为，我们需要不惜一切代价避免它。如果我们允许编译器做出实际上不正确的假设，它很容易导致关于你代码不同部分的更多错误结论，影响你整个程序。

作为一个具体例子，让我们看一个使用切片上的 get_unchecked 方法的小片段：

```rust
let a = [123, 456, 789];
let b = unsafe { a.get_unchecked(index) };
```
get_unchecked 方法给我们一个切片的元素，给出它的索引，就像 a[index]，但允许编译器假设索引总是在界内，没有任何检查。

这意味着在这个代码片段中，因为 a 的长度为 3，编译器可能会假设 index 小于三。我们有责任确保它的假设成立。

如果我们违反这个假设，例如如果我们使用索引等于 3 运行这个，可能会发生任何事情。它可能导致从内存中读取存储在 a 后面的字节。它可能导致程序崩溃。它可能最终执行程序的一些完全不相关的部分。它可能导致各种混乱。

也许令人惊讶的是，未定义行为甚至可以"回溯"，在之前的代码中引起问题。为了理解这是如何发生的，假设我们在前面的代码片段之前有一个 match 语句，如下所示：

```rust
match index {
   0 => x(),
   1 => y(),
   _ => z(index),
}

let a = [123, 456, 789];
let b = unsafe { a.get_unchecked(index) };
```
因为不安全代码，编译器被允许假设 index 只能是 0、1 或 2。它可能会逻辑地得出我们的 match 语句的最后一臂只能匹配 2，因此 z 只能被调用为 z(2)。那个结论可能不仅被用来优化 match，还可以优化 z 本身。这包括丢弃代码的未使用部分。

如果我们以索引 3 执行此操作，我们的程序可能会尝试执行已经被优化掉的部分，导致完全不可预测的行为，这发生在我们到达最后一行上的不安全块之前很久。就这样，未定义行为可以通过整个程序传播，以经常非常意外的方式，向前和向后。

当调用任何不安全函数时，仔细阅读其文档，并确保您完全理解其安全要求：您需要维护的假设，作为调用者，以避免未定义行为。

内部可变性

前面一节介绍的借用规则简单，但有时可以非常限制——尤其是当涉及到多个线程时。遵循这些规则使线程之间的通信极其有限，几乎不可能，因为多个线程可访问的任何数据都不能被修改。

幸运的是，有一个逃生舱：内部可变性。具有内部可变性的数据类型稍微弯曲了共享借用的规则，以允许在共享时发生突变。

在"引用计数"中，我们已经看到了一个关于内部可变性的微妙例子。Rc 和 Arc 都会

突变一个引用计数器，即使可能有多个克隆都在使用相同的引用计数器。

一旦涉及到内部可变类型，称呼一个引用为"不可变"或"可变"变得令人困惑和不准确，因为有些东西可以通过两者进行突变。更准确的术语是"共享"和"独占"：共享引用（&T）可以被复制并与他人共享，而独占引用（&mut T）保证它是对那个 T 的唯一独占借用。对于大多数类型，共享引用不允许突变，但有例外。由于在本书中我们将主要使用这些例外，我们将在本书的其余部分使用更准确的术语。

请记住，内部可变性只弯曲了共享借用的规则以允许突变。它没有改变关于独占借用的任何事情。独占借用仍然保证没有其他活动借用。不安全代码导致对某物有多于一个活动的独占引用总是会引起未定义行为，无论内部可变性如何。

让我们看一些具有内部可变性的类型以及它们如何允许通过共享引用进行突变而不引起未定义行为。

Cell
std::cell::Cell<T> 只是简单地包装了一个 T，但允许通过共享引用进行突变。为了避免未定义行为，它只允许您将值作为整体复制出来（如果 T 是 Copy 的），或者用另一个值整体替换它。此外，它只能在单个线程中使用。

让我们看一个类似于前一节中的例子，但这次使用 Cell<i32> 而不是 i32：

```rust
use std::cell::Cell;

fn f(a: &Cell<i32>, b: &Cell<i32>) {
    let before = a.get();
    b.set(b.get() + 1);
    let after = a.get();
    if before != after {
        x(); // might happen
    }
```
与上次不同，现在 if 条件可能为真。因为 Cell<i32> 有内部可变性，编译器不能再假设我们有共享引用时它的值不会改变。a 和 b 可能引用相同的值，这样通过 b 进行突变可能会影响 a。然而，它仍然可以假设没有其他线程并发访问单元格。

Cell 的限制并不总是容易使用。由于它不能直接让我们借用它持有的值，我们需要将值移出（留下某物在它的位置），修改它，然后放回，以突变它的内容：

```rust
fn f(v: &Cell<Vec<i32>>) {
    let mut v2 = v.take(); // Replaces the contents of the Cell with an empty Vec
    v2.push(1);
    v.set(v2); // Put the modified Vec back
}
```
RefCell
与普通 Cell 不同，std::cell::RefCell 确实允许您借用它的内容，但以小的运行时成本为代价。RefCell<T> 不仅持有一个 T，还持有一个计数器，用于跟踪任何未完成的借用。如果您尝试在它已经被可变借用的情况下借用它（反之亦然），它将 panic，这避免了未定义行为。就像 Cell 一样，RefCell 只能在单个线程中使用。

借用 RefCell 的内容是通过调用 borrow 或 borrow_mut 来完成的：

```rust
use std::cell::RefCell;

fn f(v:

 &RefCell<Vec<i32>>) {
    v.borrow_mut().push(1); // We can modify the `Vec` directly.
}
```
虽然 Cell 和 RefCell 可以非常有用，但当我们需要处理多个线程时它们变得相当无用。所以让我们继续讨论与并发相关的类型。

Mutex 和 RwLock
读写锁或读者-写者锁是 RefCell 的并发版本。RwLock<T> 持有一个 T，并跟踪任何未完成的借用。然而，与 RefCell 不同，它不会在借用冲突时 panic。相反，它会阻塞当前线程——让它睡觉——等待冲突的借用消失。我们只需要耐心等待我们与数据的轮到，其他线程完成后。

借用 RwLock 的内容称为锁定。通过锁定它，我们暂时阻止并发的冲突借用，允许我们借用它而不引起数据竞争。

Mutex 非常相似，但概念上稍微简单一些。与 RwLock 跟踪共享和独占借用的数量不同，它只允许独占借用。

我们将在"锁定：互斥锁和 RwLock"中更详细地讨论这些类型。

原子
原子类型代表 Cell 的并发版本，是第 2 章和第 3 章的主题。像 Cell 一样，它们通过让我们将值作为整体复制出来和进去，而不是直接让我们借用内容，避免了未定义行为。

与 Cell 不同的是，它们不能是任意大小的。因为这个，没有一个通用的 Atomic<T> 类型适用于任何 T，但有特定的原子类型，如 AtomicU32 和 AtomicPtr<T>。可用的原子取决于平台，因为它们需要处理器的支持来避免数据竞争。（我们将在第 7 章中深入讨论。）

由于它们在大小上如此有限，原子通常不直接包含需要在线程之间共享的信息。相反，它们通常用作使在线程之间共享其他——通常更大的——东西成为可能的工具。当原子用来说明其他数据时，事情可能会变得出奇地复杂。

UnsafeCell
UnsafeCell 是内部可变性的基本构建块。

UnsafeCell<T> 包装了一个 T，但没有任何条件或限制来避免未定义行为。相反，它的 get() 方法只给出了一个指向它包装的值的原始指针，这只能在不安全块中有意义地使用。它留给用户以不引起任何未定义行为的方式使用它。

最常见的是，UnsafeCell 不是直接使用的，而是包装在另一个类型中，通过有限的接口提供安全性，如 Cell 或 Mutex。所有具有内部可变性的类型——包括上面讨论的所有类型——都建立在 UnsafeCell 的基础上。

线程安全：Send 和 Sync
在本章中，我们看到了几种不是线程安全的类型，只能在单个线程上使用的类型，如 Rc、Cell 等。由于这种限制是为了避免未定义行为而需要的，这是编译器需要为您理解和检查的东西，以便您可以安全地使用这些类型而不必使用不安全块。

该语言使用两个特殊的 trait 来跟踪哪些类型可以安全地在线程之间使用：

Send
如果一个类型是 Send，则它可以被发送到另一个线程。换句话说，如果该类型的值的所有

权可以转移到另一个线程。例如，Arc<i32> 是 Send，但 Rc<i32> 不是。

Sync
如果一个类型是 Sync，则它可以与另一个线程共享。换句话说，一个类型 T 是 Sync 当且仅当该类型的共享引用，&T，是 Send。例如，i32 是 Sync，但 Cell<i32> 不是。（然而，Cell<i32> 是 Send 的。）

所有基本类型，如 i32、bool 和 str，都是 Send 和 Sync。

这两个 trait 都是自动 trait，这意味着它们基于它们的字段自动为您的类型实现。一个字段都是 Send 和 Sync 的结构体本身也是 Send 和 Sync。

选择退出任何一个的方法是在您的类型中添加一个不实现该 trait 的字段。为此，特殊的 std::marker::PhantomData<T> 类型经常派上用场。该类型被编译器视为 T，除了它实际上在运行时不存在。它是一个零大小类型，不占用任何空间。

让我们看看以下结构体：

```rust
use std::marker::PhantomData;

struct X {
    handle: i32,
    _not_sync: PhantomData<Cell<()>>,
}
```
在这个例子中，如果 handle 是它唯一的字段，X 将是 Send 和 Sync。然而，我们添加了一个零大小的 PhantomData<Cell<()>> 字段，它被视为一个 Cell<()>。由于 Cell<()> 不是 Sync，X 也不是。然而，它仍然是 Send 的，因为它的所有字段都实现了 Send。

原始指针（*const T 和 *mut T）既不是 Send 也不是 Sync，因为编译器对它们代表什么了解不多。

选择加入任何一个的方式与任何其他 trait 相同；使用 impl 块为您的类型实现 trait：

```rust
struct X {
    p: *mut i32,
}

unsafe impl Send for X {}
unsafe impl Sync for X {}
```
请注意，实现这些 trait 需要 unsafe 关键字，因为编译器无法为您检查是否正确。这是您向编译器承诺的，它只能信任。

如果您尝试将某物移动到另一个线程，而它不是 Send，编译器将礼貌地阻止您这样做。这里有一个小例子来演示这一点：

```rust
fn main() {
    let a = Rc::new(123);
    thread::spawn(move || { // Error!
        dbg!(a);
    });
}
```
在这里，我们尝试将 Rc<i32> 发送到一个新线程，但 Rc<i32>，与 Arc<i32> 不同，不实现 Send。

如果我们尝试编译上面的例子，我们会面临看起来像这样的错误：

```
error[E0277]: `Rc<i32>` cannot be sent between threads safely
   --> src/main.rs:3:5
    |
3   |     thread::spawn(move || {
    |     ^^^^^^^^^^^^^ `Rc<i32>` cannot be sent between threads safely
    |
    = help: within `[closure]`, the trait `Send` is not implemented for `Rc<i32>`
note: required because it's used within this closure
   --> src/main.rs:3:19
    |
3   |     thread::spawn(move || {
    |                   ^^^^^^^
note: required by a bound in `spawn`
```
thread::spawn 函数要求其参数是 Send 的，闭包只有在其捕获的所有东西都是时才是 Send。如果我们尝试捕获不是 Send 的东西，我们的错误会被捕获，保护我们免受未定义行为。

锁定：互斥锁和 RwLock
共享（可变）数据在多个线程之间的最常用工具是互斥锁，简称为"互斥"。互斥锁的工作是通过暂时阻止其他试图同时访问

的线程来确保线程对某些数据有独占访问。这是通过让所有线程都同意只在锁定互斥锁时访问数据来实现的。这样，没有两个线程可以同时访问该数据并导致数据竞争。

从概念上讲，互斥锁只有两种状态：锁定和解锁。当一个线程锁定一个未锁定的互斥锁时，互斥锁被标记为锁定，并且线程可以立即继续。当一个线程尝试锁定一个已经锁定的互斥锁时，该操作将阻塞。线程在等待互斥锁解锁时被置于休眠状态。只有在互斥锁被锁定的情况下才能解锁，应该由锁定它的同一个线程来做。如果其他线程正在等待锁定互斥锁，解锁将导致其中一个线程被唤醒，以便它可以尝试再次锁定互斥锁并继续其过程。

通过互斥锁保护数据只是所有线程之间的协议，它们只在锁定互斥锁时访问数据。这样，没有两个线程可以同时访问该数据并引起数据竞争。

Rust 的 Mutex

Rust 标准库通过 std::sync::Mutex<T> 提供了这个功能。它是泛型的，类型 T 是互斥锁保护的数据的类型。通过使这个 T 成为互斥锁的一部分，数据只能通过互斥锁访问，允许安全接口可以保证所有线程都遵守协议。

为了确保一个被锁定的互斥锁只能被锁定它的线程解锁，它没有 unlock() 方法。相反，它的 lock() 方法返回一个特殊类型称为 MutexGuard。这个守护者代表我们已经锁定了互斥锁的保证。它通过 DerefMut trait 表现得像一个独占引用，给我们独占访问互斥锁保护的数据。解锁互斥锁是通过丢弃守卫来完成的。当我们丢弃守卫时，我们放弃了访问数据的能力，守卫的 Drop 实现将解锁互斥锁。

让我们看一个例子，看看互斥锁在实践中是如何工作的：

```rust
use std::sync::Mutex;

fn main() {
    let n = Mutex::new(0);
    thread::scope(|s| {
        for _ in 0..10 {
            s.spawn(|| {
                let mut guard = n.lock().unwrap();
                for _ in 0..100 {
                    *guard += 1;
                }
            });
        }
    });
    assert_eq!(n.into_inner().unwrap(), 1000);
}
```
在这里，我们有一个 Mutex<i32>，一个保护整数的互斥锁，我们产生十个线程，每个线程都增加整数一百次。每个线程首先锁定互斥锁以获得 MutexGuard，然后使用该守卫访问并修改整数。守卫在之后直接在变量超出范围时隐式丢弃。

线程完成后，我们可以安全地通过 into_inner() 从整数中移除保护。into_inner 方法接受互斥锁的所有权，这保证了没有其他东西可以再有对互斥锁的引用，使锁定不必要。

尽管增量以一的步骤发生，观察整数的

线程只会看到 100 的倍数，因为它只能在互斥锁解锁时查看整数。有效地，由于互斥锁，一百个增量一起现在是一个单一不可分割的——原子——操作。

为了清楚地看到互斥锁的效果，我们可以让每个线程在解锁互斥锁之前等待一秒钟：

```rust
use std::time::Duration;

fn main() {
    let n = Mutex::new(0);
    thread::scope(|s| {
        for _ in 0..10 {
            s.spawn(|| {
                let mut guard = n.lock().unwrap();
                for _ in 0..100 {
                    *guard += 1;
                }
                thread::sleep(Duration::from_secs(1)); // New!
            });
        }
    });
    assert_eq!(n.into_inner().unwrap(), 1000);
}
```
当您现在运行程序时，您会看到它需要大约 10 秒钟才能完成。每个线程只等待一秒钟，但互斥锁确保一次只有一个线程这样做。

如果我们在睡眠一秒钟之前丢弃守卫——因此解锁互斥锁——我们会看到它以并行方式发生：

```rust
fn main() {
    let n = Mutex::new(0);
    thread::scope(|s| {
        for _ in 0..10 {
            s.spawn(|| {
                let mut guard = n.lock().unwrap();
                for _ in 0..100 {
                    *guard += 1;
                }
                drop(guard); // New: drop the guard before sleeping!
                thread::sleep(Duration::from_secs(1));
            });
        }
    });
    assert_eq!(n.into_inner().unwrap(), 1000);
}
```
有了这个改变，这个程序只需要大约一秒钟，因为现在 10 个线程可以同时执行它们的一秒钟睡眠。这显示了尽可能短地保持互斥锁锁定的重要性。保持互斥锁锁定的时间比必要的时间长可能会完全抵消并行性的好处，实际上强制一切都以串行方式发生。

锁中毒
上面例子中的 unwrap() 调用与锁中毒相关。

当一个线程在持有锁的时候 panic 时，Rust 中的 Mutex 会被标记为中毒。当发生这种情况时，Mutex 不再被锁定，但调用其 lock 方法将导致 Err，表明它已经中毒了。

这是一种保护机制，用于防止由互斥锁保护的数据处于不一致状态。在我们上面的例子中，如果一个线程在增加整数少于 100 次之后 panic，则互斥锁将解锁，并且整数将处于意外状态，不再是 100 的倍数，可能破坏其他线程对该数据的假设。自动将互斥锁标记为中毒在这种情况下迫使用户处理这种可能性。

调用一个中毒的互斥锁的 lock() 仍然会锁定互斥锁。lock() 返回的 Err 包含 MutexGuard，允许我们纠正不一致的状态，如果需要的话。

虽然锁中毒似乎是一个强大的机制，但在实践中很少尝试从潜在不一致的状态中恢复。大多数代码要么忽略中毒，要么使用 unwrap() 在锁被中毒时 panic，有效地将 panic 传播给所有使用互斥锁的用户。

MutexGuard 的生命周期
虽然隐式丢弃守卫解锁互斥锁很方便，但有时可能导致微妙的惊喜

。如果我们用 let 语句给守卫赋一个名称（如我们上面的例子中），看到它何时被丢弃相对直接，因为局部变量在它们定义的范围结束时被丢弃。然而，不显式地丢弃守卫可能导致互斥锁被锁定的时间比必要的时间长，正如上面的例子所示。

不给守卫赋名也是可能的，有时可以非常方便。由于 MutexGuard 表现得像一个独占引用到受保护的数据，我们可以直接使用它而不是首先给守卫赋一个名称。例如，如果您有一个 Mutex<Vec<i32>>，您可以锁定互斥锁，将一个项目推入 Vec，然后再次解锁互斥锁，在一个单独的语句中：

```rust
list.lock().unwrap().push(1);
```
在更大表达式中产生的任何临时变量，如 lock() 返回的守卫，将在语句结束时被丢弃。虽然这可能看起来明显且合理，但这会导致一个常见的陷阱，通常涉及 match、if let 或 while let 语句。这里有一个例子，遇到了这个陷阱：

```rust
if let Some(item) = list.lock().unwrap().pop() {
    process_item(item);
}
```
如果我们的意图是锁定列表，弹出一个项目，解锁列表，然后在列表解锁后处理该项目，我们犯了一个微妙但重要的错误。临时守卫直到整个 if let 语句结束才被丢弃，这意味着我们不必要地保持锁定，同时处理该项目。

也许令人惊讶的是，对于类似的 if 语句，这种情况不会发生，如下面的例子所示：

```rust
if list.lock().unwrap().pop() == Some(1) {
    do_something();
}
```
在这里，临时守卫在 if 语句的主体被执行之前确实被丢弃了。原因是常规 if 语句的条件总是一个简单的布尔值，它不能借用任何东西。没有理由将条件中的临时变量的生命周期延长到整个语句的末尾。对于 if let 语句，然而，可能不是这种情况。如果我们使用的是 front() 而不是 pop()，例如，item 将从列表中借用，使得必须保持守卫到语句的末尾。由于借用检查器只是一个检查，不影响何时或以什么顺序丢弃东西，即使我们使用 pop() 也是如此，尽管那不是必要的。

我们可以通过将 pop 操作移到一个单独的 let 语句中来避免这个问题。然后守卫在该语句结束时被丢弃，在 if let 之前：

```rust
let item = list.lock().unwrap().pop();
if let Some(item) = item {
    process_item(item);
}
```
读者-写者锁
互斥锁只关心独占访问。MutexGuard 将为我们提供一个独占引用（&mut T）到保护的数据，即使我们只想查看数据，共享引用（&T）就足够了。

读者-写者锁是互斥锁的稍微复杂一些的版本，它理解独占和共享访问之间的区别，并且可以提供任何一个。它有三种状态：未锁定、被单个写者

锁定（用于独占访问）和被任意数量的读者锁定（用于共享访问）。它通常用于经常被多个线程读取的数据，但偶尔更新一次。

Rust 标准库通过 std::sync::RwLock<T> 类型提供这个锁。它的工作方式与标准 Mutex 类似，除了其接口主要分为两部分。它没有一个单一的 lock() 方法，而是有一个 read() 和 write() 方法用于作为读者或写者锁定。它带有两种守卫类型，一种用于读者，一种用于写者：RwLockReadGuard 和 RwLockWriteGuard。前者只实现了 Deref 以表现得像对受保护数据的共享引用，而后者还实现了 DerefMut 以表现得像独占引用。

它实际上是 RefCell 的多线程版本，动态跟踪引用的数量以确保借用规则得到维护。

Mutex<T> 和 RwLock<T> 都要求 T 是 Send 的，因为它们可以用来将 T 发送到另一个线程。RwLock<T> 还要求 T 实现 Sync，因为它允许多个线程持有受保护数据的共享引用（&T）。（严格来说，您可以为不满足这些要求的 T 创建锁，但您将无法在线程之间共享它，因为锁本身不会实现 Sync。）

Rust 标准库只提供了一个通用的 RwLock 类型，但其实现取决于操作系统。读者-写者锁实现之间有许多微妙的变化。大多数实现会在有写者等待时阻塞新的读者，即使锁已经被读锁定。这样做是为了防止写者饥饿，一种情况是许多读者集体阻止锁从未解锁，从不允许任何写者更新数据。

其他语言中的 Mutex
Rust 的标准 Mutex 和 RwLock 类型与其他语言中的那些看起来有点不同，如 C 或 C++。

最大的区别是 Rust 的 Mutex<T> 包含它正在保护的数据。例如，在 C++ 中，std::mutex 不包含它保护的数据，甚至不知道它保护的是什么。这意味着用户有责任记住哪些数据受哪个互斥锁保护，并确保每次访问"受保护"数据时都锁定正确的互斥锁。当阅读其他语言中涉及互斥锁的代码或与不熟悉 Rust 的程序员交流时，记住这一点很有用。一个 Rust 程序员可能会谈论"互斥锁中的数据"，或说诸如"将其包裹在互斥锁中"之类的话，这可能会让那些只熟悉其他语言中互斥锁的人感到困惑。

如果您真的需要一个不包含任何东西的独立互斥锁，例如用于保护一些外部硬件，您可以使用 Mutex<() >。但即使在这种情况下，您可能最好还是定义一个（可能是零大小的）类型来与该硬件交互，并将其包装在 Mutex 中。这样，您仍然被迫在与硬件交互之前锁定互斥锁。

等待：停车和条件变量
当多个线程修改数据时，有许多情况下它们需要等待某个事件，等待某些关于数据的条件变为

真。例如，如果我们有一个互斥锁保护的 Vec，我们可能想等到它包含任何东西。

虽然互斥锁确实允许线程等待它变为解锁，但它不提供等待任何其他条件的功能。如果互斥锁是我们所拥有的一切，我们将不得不不断锁定互斥锁以重复检查 Vec 是否已经包含任何东西。

线程停车
一种等待来自另一个线程的通知的方法称为线程停车。线程可以停车自己，这使它进入睡眠状态，停止消耗任何 CPU 周期。然后另一个线程可以解除停车的线程，将它从小睡中唤醒。

线程停车可通过 std::thread::park() 函数获得。要解除停车，您在代表您想要解除停车的线程的 Thread 对象上调用 unpark() 方法。这样的对象可以从 spawn 返回的 join 句柄获取，或者通过 std::thread::current() 由线程本身获取。

让我们深入一个例子，使用互斥锁在两个线程之间共享队列。在以下示例中，新产生的线程将从队列中消费项目，而主线程将每秒向队列中插入一个新项目。线程停车用于使消费线程等待，当队列为空时。

```rust
use std::collections::VecDeque;

fn main() {
    let queue = Mutex::new(VecDeque::new());

    thread::scope(|s| {
        // Consuming thread
        let t = s.spawn(|| loop {
            let item = queue.lock().unwrap().pop_front();
            if let Some(item) = item {
                dbg!(item);
            } else {
                thread::park();
            }
        });

        // Producing thread
        for i in 0.. {
            queue.lock().unwrap().push_back(i);
            t.thread().unpark();
            thread::sleep(Duration::from_secs(1));
        }
    });
}
```
消费线程运行一个无限循环，在其中从队列中弹出项目以使用 dbg 宏显示它们。当队列为空时，它停止并使用 park() 函数进入睡眠。如果它被解除停车，park() 调用返回，循环继续，从队列中弹出项目，直到它为空。如此循环往复。

我们需要注意的一个重要观察是，如果我们移除停车，这个程序理论上仍然是正确的，尽管效率低下。这很重要，因为 park() 并不保证它只会因为匹配的 unpark() 返回。虽然有些罕见，但它可能有虚假唤醒。我们的例子可以很好地处理这个，因为消费线程将锁定队列，看到它是空的，直接解锁它并再次停车自己。

线程停车的一个重要属性是，在线程停车自己之前对 unpark() 的调用不会丢失。请求解除停车仍然被记录，下次线程尝试停车自己时，它会清除该请求并直接继续而不实际进入睡眠。为了看到这对正确操作至关重要，让我们经历两个线程执行的步骤的可能顺序：

消费线程——我们称之为 C——锁定队列。

C 尝试从队列中弹出一个项目，但它是空的，导致 None。

C 解锁队列。

生产线程，我们称之为 P，锁定队列。

P 将一个新项目推入队列。

P 再次解锁队列。

P 调用 unpark() 通知 C 有新项目。

C 调用 park() 进入睡眠，等待更多项目

。

虽然在步骤 3 释放队列和步骤 8 停车之间可能只有非常短暂的时刻，步骤 4 到 7 可能在线程停车自己之前的那一刻发生。如果 unpark() 在线程没有停车时什么也不做，通知将丢失。消费线程仍然在等待，即使队列中有一个项目。由于 unpark() 请求被保存到将来的 park() 调用，我们不必担心这个问题。

然而，unpark() 请求不会堆叠。调用 unpark() 两次然后调用 park() 两次之后仍然导致线程进入睡眠。第一个 park() 清除请求并直接返回，但第二个如常进入睡眠。

这意味着在我们上面的例子中，只有在我们看到队列为空时才停车线程很重要，而不是在处理每个项目后停车线程。虽然在这个例子中由于巨大（一秒钟）的睡眠几乎不可能发生，但多个 unpark() 调用只唤醒一个 park() 调用。

不幸的是，这确实意味着如果 unpark() 在 park() 返回后但在锁定并清空队列之前被调用，unpark() 调用是不必要的，但仍然导致下一个 park() 调用立即返回。这导致（空的）队列被多锁定和解锁一次。虽然这不影响程序的正确性，但确实影响其效率和性能。

这种机制适用于简单情况，如我们的例子，但当事情变得更复杂时很快就会崩溃。例如，如果我们有多个消费线程从同一个队列中取出项目，生产线程将不知道哪个消费者实际上在等待并应该被唤醒。生产者将不得不确切知道消费者何时在等待，以及它在等待什么条件。

条件变量
条件变量是等待某事发生的更常用的选择，用于由互斥锁保护的数据。它们有两个基本操作：等待和通知。线程可以等待条件变量，之后可以被另一个线程通知相同的条件变量唤醒。多个线程可以等待同一个条件变量，通知可以发送给一个等待的线程，或者给它们所有人。

这意味着我们可以为我们感兴趣的特定事件或条件创建一个条件变量，如队列非空，并等待该条件。任何导致该事件或条件发生的线程然后通知条件变量，而不必知道哪个或多少线程对该通知感兴趣。

为了避免在解锁互斥锁和等待条件变量之间的短暂时刻错过通知，条件变量提供了一种原子地解锁互斥锁和开始等待的方法。这意味着简单地没有可能的时刻让通知丢失。

Rust 标准库提供了条件变量作为 std::sync::Condvar。它的 wait 方法接受一个 MutexGuard，证明我们已经锁定了互斥锁。它首先解锁互斥锁并进入睡眠。后来，当被唤醒时，它重新锁定互斥锁并返回一个新的 MutexGuard（证明互斥锁再次被锁定）。

它有两个通知功能：notify_one 唤醒一个等待的线程（如果有的话），

notify_all 唤醒它们所有人。

让我们修改我们用于线程停车的例子来使用 Condvar 代替：

```rust
use std::sync::Condvar;

let queue = Mutex::new(VecDeque::new());
let not_empty = Condvar::new();

thread::scope(|s| {
    s.spawn(|| {
        loop {
            let mut q = queue.lock().unwrap();
            let item = loop {
                if let Some(item) = q.pop_front() {
                    break item;
                } else {
                    q = not_empty.wait(q).unwrap();
                }
            };
            drop(q);
            dbg!(item);
        }
    });

    for i in 0.. {
        queue.lock().unwrap().push_back(i);
        not_empty.notify_one();
        thread::sleep(Duration::from_secs(1));
    }
});
```
我们不得不改变几件事：

我们现在不仅有一个包含队列的互斥锁，还有一个 Condvar 来沟通"不为空"的条件。

我们不再需要知道唤醒哪个线程，所以我们不再存储 spawn 返回的值。相反，我们通过条件变量使用 notify_one 方法通知消费者。

通过 wait 方法解锁、等待和重新锁定是一体的。我们不得不重新组织控制流，以便能够将守卫传递给 wait 方法，同时在处理项目之前将其丢弃。

现在我们可以产生任意多的消费线程，甚至稍后再产生更多，而无需改变任何东西。条件变量负责将通知传递给任何感兴趣的线程。

如果我们有一个更复杂的系统，线程对不同条件感兴趣，我们可以为每个条件定义一个 Condvar。例如，我们可以定义一个表示队列非空的 Condvar，另一个表示它为空。然后每个线程将等待与它们正在做的事情相关的条件。

通常，Condvar 只与单个 Mutex 一起使用。如果两个线程尝试使用两个不同的互斥锁同时等待条件变量，可能会导致 panic。

Condvar 有一个缺点是它只能与 Mutex 一起使用，但对于大多数用例来说这是完全可以的，因为这正是用来保护数据的东西。

thread::park() 和 Condvar::wait() 还有一个带有时间限制的变体：thread::park_timeout() 和 Condvar::wait_timeout()。这些接受一个 Duration 作为额外的参数，这是放弃等待通知并无条件唤醒的时间。

总结
多个线程可以在同一个程序中并发运行，并且可以随时产生。

当主线程结束时，整个程序结束。

数据竞争是未定义行为，完全通过 Rust 的类型系统（在安全代码中）防止。

可以发送到其他线程的数据是 Send 的，可以从多个线程访问的数据是 Sync 的。

普通线程可能运行得和程序一样长，因此只能借用 'static 数据，如静态变量和泄漏的分配。

引用计数（Arc）可用于共享所有权，确保数据只要至少有一个线程在使用它就活着。

作用域线程对于限制线程的生命周期很有用，允许它们借用非 'static 数据，如局部变量。

&T 是共享引用。&mut T 是独占引用。常规类型不允许通过共享引用进行突变。

一些类型具有内部可变性，感谢 UnsafeCell，它允许通过共享引用进行突变。

Cell 和 RefCell 是单线程内部可变性的标准类型。原子、Mutex 和 RwLock 是它们的多线程等价物。

Cell 和原子只允许将值作为整体替换，而 RefCell、Mutex 和 RwLock 允许您通过动态执行访问规则直接突

变值。

线程停车可以是等待某个条件的便捷方式。

当条件涉及由 Mutex 保护的数据时，使用 Condvar 更方便，可以更有效率，而不是线程停车。

通过掌握这些概念，Rust 开发人员可以充分利用并发，编写健壮、高效和安全的应用程序，充分利用他们系统的硬件能力。
