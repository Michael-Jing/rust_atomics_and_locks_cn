['第四章。构建我们自己的自旋锁\n', '\n', '锁定一个常规的互斥锁（参见第1章的"锁定：互斥锁和读写锁"）会在互斥锁已被锁定时使你的线程进入睡眠状态。这避免了在等待锁释放时浪费资源。如果一个锁只在非常短的瞬间被持有，并且锁定它的线程可以在不同的处理器核心上并行运行，那么这些线程可能会更好地反复尝试锁定它，而不实际进入睡眠状态。\n', '\n', '自旋锁就是一个做到这一点的互斥锁。试图锁定一个已经锁定的互斥锁会导致忙循环或旋转：反复尝试一次又一次，直到最终成功。这可能会浪费处理器周期，但有时在锁定时可能会导致更低的延迟。\n', '\n', '许多实际的互斥锁实现，包括在某些平台上的std::sync::Mutex，在请求操作系统将线程置入睡眠状态之前，会暂时像自旋锁一样运行。这试图结合两者的优点，虽然这完全取决于特定使用情况是否有益。\n', '\n', '在本章中，我们将构建我们自己的SpinLock类型，运用我们在第2章和第3章中学到的知识，看看我们如何利用Rust的类型系统为我们的SpinLock的用户提供一个安全且有用的接口。\n', '最小实现\n', '\n', '让我们从头开始实现一个这样的自旋锁。\n', '\n', '最小版本非常简单，如下所示：\n', '\n', 'pub struct SpinLock {\n', '    locked: AtomicBool,\n', '}\n', '\n', '我们需要的只是一个单一的布尔值，指示它是否已被锁定。我们使用原子布尔值，因为我们希望超过一个的线程能同时与其交互。\n', '\n', '然后我们只需一个构造函数以及锁定和解锁的方法：\n', '\n', 'impl SpinLock {\n', '    pub const fn new() -> Self {\n', '        Self { locked: AtomicBool::new(false) }\n', '    }\n', '\n', '    pub fn lock(&self) {\n', '        while self.locked.swap(true, Acquire) {\n', '            std::hint::spin_loop();\n', '        }\n', '    }\n', '\n', '    pub fn unlock(&self) {\n', '        self.locked.store(false, Release);\n', '    }\n', '}\n', '\n', '锁定布尔值开始于false，锁定方式将其转换为true，并在已经为true时继续尝试，解锁方法恢复为false。\n', '\n', '而不是使用交换操作，我们也可以使用一个比较和交换操作来原子性地检查布尔值是否为false，如果是这样就将其设置为true：\n', '\n', '    while self.locked.compare_exchange_weak(\n', '            false, true, Acquire, Relaxed).is_err()\n', '\n', '这有点多余，但取决于你的喜好，这可能更容易理解，因为它更清晰地捕获了可以失败或成功的操作的概念。然而，这可能会产生略有不同的指令，我们将在第7章中看到。\n', '\n', '在while循环中，我们使用一个自旋循环提示，告知处理器我们正在旋转等待某些改变。在大多数主要平台上，这个提示将产生一个特殊的指令，使处理器核心优化其行为以适应这种情况。例如，它可能会暂时减缓运行或优先处理其余有用的事情。但与线程::sleep或线程::park等阻塞操作不同，自旋循环提示并不会导致操作系统被调用以将你的线程置入睡眠，以便给其他线程提供机会。\n', '\n', '一般来说，将这样的提示包含在自旋循环中是个好主意。根据情况，甚至可能在再次尝试访问原子变量之前多次执行这个提示。如果你关心最后几纳秒的性能并希望找到最优策略，你就必须对你的特定使用案例进行基准测试。不幸的是，这样的基准测试的结论可能高度依赖于硬件，我们将在第7章中看到。\n', '\n', '我们使用获取和释放内存顺序来确保每一个unlock()调用都与后续的lock()调用建立一种发生关系。换句话说，以确保在锁定它之后，我们可以安全地假设最后一次锁定它期间发生的事情已经发生。这是取得和释放顺序最经典的使用场景：获取和释放一个锁。\n', '\n', '图4-1显示了我们的SpinLock被用来保护对一些共享数据的访问，其中两个线程同时试图获取锁的情况。注意第一个线程的解锁操作是如何形成一个与第二个线程的锁定操作的发生先后关系的，这确保了线程不能同时访问数据。\n', '图4-1. 使用我们的SpinLock保护对一些共享数据的访问的两个线程之间的发生先后关系。图像描述\n', '不安全的自旋锁\n', '\n', '我们上面的SpinLock类型有一个完全安全的接口，因为，本身它不会在被误用时引发任何未定义的行为。然而，在大多数使用场景中，它将用来保护对共享变量的更改，这意味着用户仍然必须使用不安全的、未经检查的代码。\n', '\n', '为了提供一个更简单的接口，我们可以改变lock方法，使其给我们一个对锁保护的数据的独占引用（&mut T），因为在大多数使用情况下，它是通过锁操作来保证我们安全假设独占访问的。\n', '\n', '为了能够做到这一点，我们必须改变类型，使其泛用在保护数据的类型，并增加一个字段来保存这些数据。由于即使锁自身被共享，这个数据也可以被修改（或独占访问），我们需要使用内部可变性（见第1章的"内部可变性"），我们将使用UnsafeCell：\n', '\n', 'use std::cell::UnsafeCell;\n', '\n', 'pub struct SpinLock<T> {\n', '    locked: AtomicBool,\n', '    value: UnsafeCell<T>,\n', '}\n', '\n', '作为预防措施，UnsafeCell并未实现Sync，这意味着我们的类型现在无法在线程之间共享，这使得它无用了。为了解决这个问题，我们需要向编译器承诺我们的类型实际上是可以在线程间共享的。然而，由于锁可以用来从一个线程向另一个线程发送T类型的值，我们必须对所有实现了Send的T限制这个承诺，像这样：\n', '\n', 'unsafe impl<T> Sync for SpinLock<T> where T: Send {}\n', '\n', '注意，我们不需要要求T是Sync，因为我们的SpinLock<T>只会允许一个线程一次访问它保护的T。只有当我们想让多个线程一次访问，就像一个读写锁对读取者那样,我们才需要(additionally) 要求 T: Sync。\n', '\n', '下一步，我们的new函数现在需要接收一个类型T的值以初始化那个UnsafeCell:\n', '\n', 'impl<T> SpinLock<T> {\n', '    pub const fn new(value: T) -> Self {\n', '        Self {\n', '            locked: AtomicBool::new(false),\n', '            value: UnsafeCell::new(value),\n', '        }\n', '    }\n', '\n', '    …\n', '}\n', '\n', '然后我们来到了有趣的部分：锁定和解锁。我们这样做的原因是，我们希望能够从lock()中返回一个&mut T，这样用户在使用我们的锁来保护他们的数据时就不需要编写不安全的、未检查的代码。这意味着我们现在必须在我们方面使用不安全的代码，即在锁定的实现中。UnsafeCell可以通过它的get()方法给我们它的内容的一个原始指针（*mut T），我们可以在一个不安全的代码块中将它转换为引用，如下所示：\n', '\n', '    pub fn lock(&self) -> &mut T {\n', '        while self.locked.swap(true, Acquire) {\n', '            std::hint::spin_loop();\n', '        }\n', '        unsafe { &mut *self.value.get() }\n', '    }\n', '\n', '由于lock函数的函数签名在其输入和输出都包含一个引用，&self和&mut T的生命周期已经被略去并假设相同。（查看"生命周期省略"在Rust书的"第十章：泛型类型，特质，和生命周期）。我们可以通过手动写出它们来使生命周期明确，像这样：\n']['\n', "    pub fn lock<'a>(&'a self) -> &'a mut T { … }\n", '\n', '这清楚地显示了返回的引用的生命周期与&self的一样。这意味着我们声明返回的引用在锁本身存在的时间内都是有效的。\n', '\n', '如果我们假装unlock()不存在，这将是一个完全安全且有效的接口。SpinLock可以被锁定，结果是一个&mut T，然后永远不能再被锁定，这保证了这个独有的引用确实是独有的。\n', '\n', '然而，如果我们试图加回unlock()方法，我们将需要一种方式来限制返回的引用的生命周期，直到下一次调用unlock()。如果编译器能理解英文，也许这能工作：\n', '\n', "    pub fn lock<'a>(&self) -> &'a mut T\n", '    where\n', "        'a end at the next call to unlock() on self,\n", "        even if that's done by another thread.\n", '        Oh, and it also ends when self is dropped, of course.\n', '        (Thanks!)\n', '    { … }\n', '\n', '不幸的是，这在Rust中是无效的。我们不是试图向编译器解释这一限制，而是需要向用户解释。为了把责任转给用户，我们把unlock函数标记为不安全的，并留下一条短信给他们，解释他们需要做什么来保持事情的顺利进行：\n', '\n', '    /// Safety: The &mut T from lock() must be gone!\n', '    /// (And no cheating by keeping reference to fields of that T around!)\n', '    pub unsafe fn unlock(&self) {\n', '        self.locked.store(false, Release);\n', '    }\n', '\n', '使用Lock Guard提供一个安全的接口\n', '\n', '为了能够提供一个完全安全的接口，我们需要将解锁操作绑定到&mut T的末尾。我们可以通过将这个引用包装在我们自己的类型中实现，这个类型的行为像一个引用，但在被丢弃时还实现了Drop特性。\n', '\n', '这种类型通常被称作守卫（Guard），因为它有效地保护了锁的状态，直到被丢弃时仍对状态负责。\n', '\n', '我们的Guard类型将简单地包含一个对SpinLock的引用，这样在之后可以既访问其UnsafeCell也能重置AtomicBool：\n', '\n', 'pub struct Guard<T> {\n', '    lock: &SpinLock<T>,\n', '}\n', '\n', '然而，如果我们试图编译这个代码，编译器会告诉我们：\n', '\n', '错误[E0106]: 缺少生命周期说明\n', '   --> src/lib.rs\n', '    |\n', '    |         lock: &SpinLock<T>,\n', '    |               ^ 预期的命名生命周期参数\n', '    |\n', 'help: 考虑引入一个命名生命周期参数\n', '    |\n', "    ~     pub struct Guard<'a, T> {\n", '    |                      ^^^\n', "    ~         lock: &'a SpinLock<T>,\n", '    |                ^^\n', '    |\n', '\n', '很显然，生命周期不能省略的地方在这不起作用。我们必须明确这个引用有一个限定的生命周期，正如编译器所建议的：\n', '\n', "pub struct Guard<'a, T> {\n", "    lock: &'a SpinLock<T>,\n", '}\n', '\n', '这保证了Guard不能比SpinLock活得久。\n', '\n', '接下来，我们改变SpinLock的锁定方法以返回一个Guard：\n', '\n', '    pub fn lock(&self) -> Guard<T> {\n', '        while self.locked.swap(true, Acquire) {\n', '            std::hint::spin_loop();\n', '        }\n', '        Guard { lock: self }\n', '    }\n', '\n', '我们的Guard类型没有构造函数，它的字段是私有的，所以这是用户可以获得一个Guard的唯一方式。因此，我们可以安全地假设一个Guard的存在表示SpinLock已经被锁定。\n', '\n', '为了让Guard<T>像一个（专属的）引用一样行为，透明地访问T，我们需要实现特殊的Deref和DerefMut特性，如下所示：\n', '\n', 'use std::ops::{Deref, DerefMut};\n', '\n', "impl<T> Deref for Guard<'_, T> {\n", '    type Target = T;\n', '    fn deref(&self) -> &T {\n', '        // Safety: The very existence of this Guard\n', "        // guarantees we've exclusively locked the lock.\n", '        unsafe { &*self.lock.value.get() }\n', '    }\n', '}\n', '\n', "impl<T> DerefMut for Guard<'_, T> {\n", '    fn deref_mut(&mut self) -> &mut T {\n', '        // Safety: The very existence of this Guard\n', "        // guarantees we've exclusively locked the lock.\n", '        unsafe { &mut *self.lock.value.get() }\n', '    }\n', '}\n', '\n', '作为最后一步，我们为Guard实现Drop，这样我们就可以完全删除不安全的unlock方法：\n', '\n', "impl<T> Drop for Guard<'_, T> {\n", '    fn drop(&mut self) {\n', '        self.lock.locked.store(false, Release);\n', '    }\n', '}\n']['\n', '就这样，通过Drop和Rust的类型系统的魔力，我们为我们的SpinLock类型提供了一个完全安全（并且有用）的接口。\n', '\n', '让我们试试看：\n', '\n', 'fn main() {\n', '    let x = SpinLock::new(Vec::new());\n', '    thread::scope(|s| {\n', '        s.spawn(|| x.lock().push(1));\n', '        s.spawn(|| {\n', '            let mut g = x.lock();\n', '            g.push(2);\n', '            g.push(2);\n', '        });\n', '    });\n', '    let g = x.lock();\n', '    assert!(g.as_slice() == [1, 2, 2] || g.as_slice() == [2, 2, 1]);\n', '}\n', '\n', '以上程序演示了我们的SpinLock使用起来有多么简单。得益于Deref和DerefMut，我们可以直接在保镖上调用Vec::push方法。而感谢Drop，我们不需要担心解锁的问题。\n', '\n', '显式解锁也是可能的，通过调用drop(g)来丢弃保镖。如果你尝试过早解锁，你会看到代码检查出现的错误提示。例如，如果你在两行push(2)之间插入drop(g);，第二个push将无法编译，因为你在这时已经丢弃了g：\n', '\n', 'error[E0382]: borrow of moved value: `g`\n', '   --> src/lib.rs\n', '    |\n', '    |     drop(g);\n', '    |          - value moved here\n', '    |     g.push(2);\n', '    |     ^^^^^^^^^ value borrowed here after move\n', '\n', '多亏了Rust的类型系统，我们可以确保在我们甚至运行我们的程序之前就捕捉到了这样的错误。\n', '总结\n', '\n', '    自旋锁是一种互斥锁，它在等待时会忙循环，或者说自旋。\n', '\n', '    自旋可以减少延迟，但也可能浪费时钟周期并降低性能。\n', '\n', '    自旋循环提示，std::hint::spin_loop()，可以用来通知处理器一个自旋循环，从而可能提高其效率。\n', '\n', '    只需一个AtomicBool和一个UnsafeCell<T>，就可以实现一个SpinLock<T>，其中后者是必要的，因为它需要内部可变性（请参阅第一章中的"内部可变性"）。\n', '\n', '    为防止数据竞争（这将导致未定义的行为）需要在解锁和锁定操作之间存在一种发生前关系。\n', '\n', '    获取和释放内存排序对于这种用例来说非常适合。\n', '\n', '    当做出必要的未经检查的假设以避免未定义的行为时，可以通过使函数不安全来将责任转移给调用者。\n', '\n', '    Deref和DerefMut特性可以被用来使类型像引用一样行为，从而透明地提供对另一个对象的访问。\n', '\n', '    Drop特性可以被用来在对象被删除时做一些事情，例如当它超出范围或被传递给drop()时。\n', '\n', '    锁保镖是一种特殊类型的有用设计模式，用于表示对锁定的锁（安全）访问。这种类型通常的行为类似于引用，这要归功于Deref特性，而且通过Drop特性实现了自动解锁。 \n']