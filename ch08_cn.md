['第8章. 操作系统基元\n', '\n', '到目前为止，我们主要关注非阻塞操作。如果我们想实现类似互斥体或条件变量的东西，等待另一个线程解锁或通知它，我们需要一种有效阻塞当前线程的方法。\n', '\n', '如我们在第四章中看到的，我们可以通过旋转来自行实现，反复试图做同一个事情，这样可能会轻易浪费大量的处理器时间。然而，如果我们想要有效地阻塞，我们就需要操作系统内核的帮助了。\n', '\n', '内核，或者更具体地说它的调度器部分，负责决定哪个进程或线程何时、多久以及在哪个处理器核心上运行。当一个线程在等待某件事情发生的时候，内核可以停止给予它任何处理器时间，优先考虑其他能更好地使用这种稀缺资源的线程。\n', '\n', '我们需要一种方法来告诉内核我们正在等待某件事情，并请求它让我们的线程休眠，直到发生一些相关的事情。\n', '与内核的接口\n', '\n', '与内核通信的方式很大程度上取决于操作系统，甚至常常取决于其版本。通常，这些工作的具体细节会隐藏在一个或多个库中来处理。例如，使用 Rust 标准库，我们只需要调用 File::open() 来打开一个文件，而不需要知道任何有关操作系统内核接口的细节。同样，使用 C 标准库 libc，我们可以调用标准的 fopen() 函数来打开文件。调用这样的函数最终会导致一个调用到操作系统内核的调用，也就是一个系统调用，这通常是通过一种专用的处理器指令完成的。 (在一些架构上，这个指令就叫做 syscall。)\n', '\n', '一般来说，程序被期望，有时甚至被要求，不直接进行任何系统调用，而是使用操作系统提供的更高级的库。在 Unix 系统上，如基于 Linux 的系统，libc 扮演这个提供标准接口到内核的特殊角色。\n', '\n', '"便携式操作系统接口"标准，更为人所熟知的 POSIX 标准，对 Unix 系统上的 libc 提出了额外的要求。例如，除了 C 标准的 fopen() 函数外，POSIX 还额外要求存在低级的 open() 和 openat() 函数来打开文件，这些函数通常直接对应一个系统调用。由于 libc 在 Unix 系统上的特殊地位，除 C 语言以外的其他语言编写的程序通常也仍然使用 libc 来处理所有与内核的交互。\n', '\n', '包括标准库在内的 Rust 软件，经常通过同名的 libc crate 来使用 libc。\n', '\n', '对于 Linux 而言，系统调用接口被保证是稳定的，这使我们可以直接做系统调用，而不用通过 libc。尽管这不是最常见或最建议的方式，但它正慢慢变得更受欢迎。\n', '\n', '然而，在 macOS 上，也是遵循 POSIX 标准的 Unix 操作系统，内核的系统调用接口并不稳定，我们不应该直接使用它。 程序被允许使用的唯一稳定接口是由系统提供的库，如 libc、libc++，以及为 C、C++、Objective-C 和 Swift（Apple’s 选择的编程语言）等各种语言提供的各种其他库。\n', '\n', 'Windows 并不遵循 POSIX 标准。 它并不是使用扩展版的 libc作为主要的内核接口，而是使用一套单独的库，如 kernel32.dll，该库提供了一些 Windows 特有的函数，如 CreateFileW 用于打开文件。就像在 macOS 上一样，我们不应该使用未经文档描述的底层函数或直接进行系统调用。\n', '\n', '通过他们的库，操作系统为我们提供了需要与内核交互的同步基元，如互斥锁和条件变量。这些实现的哪一部分属于库或属于内核在不同的操作系统中差别很大。例如，有时互斥锁的锁定和解锁操作会直接对应一个内核的系统调用，而在其他系统上，库会处理大部分操作，并且只在需要阻塞或唤醒线程时执行一个系统调用。（后者往往更有效率，因为系统调用可能会很慢。）\n', 'POSIX\n', '\n', '作为 POSIX 线程扩展的一部分，更为人所熟知的 posix 线程，POSIX 规定了并发的数据类型和函数。虽然技术上这是作为一个单独的系统库 libpthread 来规定的，但现在这些功能常常被直接包含在 libc 中。\n', '\n', '除了像创建和连接线程 (pthread_create 和 pthread_join) 这样的功能外，pthread 还提供了最常见的同步基元：互斥锁 (pthread_mutex_t)，读写锁 (pthread_rwlock_t)，和条件变量 (pthread_cond_t）。\n', '\n', 'pthread_mutex_t\n', '\n', '    Pthread 的互斥体必须通过调用 pthread_mutex_init() 进行初始化，并通过 pthread_mutex_destroy() 进行销毁。初始化函数接受一个类型为 pthread_mutexattr_t 的参数，可以用来配置互斥体的一些属性。\n', '\n', '    其中的一个属性是它在递归锁定时的行为，这种情况发生在已经持有锁的同一个线程试图再次锁定。在默认设置下（PTHREAD_MUTEX_DEFAULT），这种行为会导致未定义的行为，但也可以配置为导致错误（PTHREAD_MUTEX_ERRORCHECK），导致死锁（PTHREAD_MUTEX_NORMAL），或者成功地进行第二次锁定（PTHREAD_MUTEX_RECURSIVE）。\n', '\n', '    这些互斥体是通过 pthread_mutex_lock() 或 pthread_mutex_trylock() 加锁的，通过 pthread_mutex_unlock() 解锁。另外，和 Rust 的标准互斥体不同，它们还支持有时限的锁定，通过 pthread_mutex_timedlock()。\n', '\n', '    一个 pthread_mutex_t 可以通过将其赋值为 PTHREAD_MUTEX_INITIALIZER 来在没有调用 pthread_mutex_init() 的情况下进行静态初始化。然而，这只对默认设置的互斥体可行。\n', 'pthread_rwlock_t\n', '\n', '    Pthread 的读写锁通过 pthread_rwlock_init() 和 pthread_rwlock_destroy() 初始化和销毁。和互斥体类似，一个默认的 pthread_rwlock_t 也可以通过 PTHREAD_RWLOCK_INITIALIZER 静态地初始化。\n', '\n', '    一个 pthread 的读写锁可通过其初始化函数配置的属性明显少于 pthread 的互斥体。最明显的是，试图递归地进行写锁定总是会导致死锁。\n', '\n', '    然而，试图递归地获取额外的读锁是可以保证成功的，即使有等待的写入者存在。这有效地排除了任何优先考虑写入者而不是读取者的有效实现，这就是为什么大多数 pthread 实现会优先考虑读取者。\n', '\n', '    它的接口与 pthread_mutex_t 几乎完全一样，包括对时限的支持，除了每个锁定函数都有两种变体：一种用于读取者 (pthread_rwlock_rdlock),另一种用于写入者 (pthread_rwlock_wrlock)。或许令人惊讶的是，只有一个解锁函数 (pthread_rwlock_unlock)，用于解锁任一种类型的锁。\n', 'pthread_cond_t\n', '\n', '    一个 pthread 的条件变量与一个 pthread 的互斥体一起使用。它通过 pthread_cond_init 和 pthread_cond_destroy 初始化和销毁，并且有一些可以配置的属性。最值得注意的是，我们可以配置时间限制是使用单调时钟 (像 Rust 的 Instant)还是真实时钟 (如 Rust 的 SystemTime，有时被称为 "wall-clock time")。一种具有默认设置的条件变量，例如由 PTHREAD_COND_INITIALIZER 静态初始化的条件变量，使用的是真实时钟。\n', '\n', '    对这样一个条件变量的等待，可以选择性地带有时间限制，是通过 pthread_cond_timedwait() 完成的。唤醒一个等待的线程是通过调用 pthread_cond_signal() ，或者一次性唤醒所有等待的线程，通过调用 pthread_cond_broadcast()。\n', '\n', '剩下的由 pthread 提供的同步基元是屏障 (pthread_barrier_t), 自旋锁 (pthread_spinlock_t),以及一次性初始化 (pthread_once_t)，这些我们将不讨论。\n', '在 Rust 中的封装\n', '\n', '我们似乎可以很容易地通过方便地将他们的 C 类型 (通过 libc crate)封装在 Rust 结构中来将这些 pthread 同步基元暴露给 Rust，像这样：\n', '\n', 'pub struct Mutex {\n', '    m: libc::pthread_mutex_t,\n', '}\n', '\n', '然而，由于这个 pthread 类型是为 C 而设计的，而不是为 Rust，所以有一些问题。\n', '\n', '首先，Rust 有一些关于可变性和借用的规则，这些规则通常不允许在被共享的情况下进行修改。因为函数像 pthread_mutex_lock 很可能会修改互斥体，所以我们需要内部可变性来确保这是可接受的。所以，我们需要把它封装在一个 UnsafeCell 中：\n', '\n', 'pub struct Mutex {\n', '    m: UnsafeCell<libc::pthread_mutex_t>,\n', '}\n', '\n', '一个更大的问题是有关移动的。\n', '\n', '在 Rust 中，我们全时都在搬移对象。例如，通过从函数中返回一个对象，将它作为参数传递，或者简单地把它分配到一个新的地方。我们拥有的任何东西（并且没有被任何其他东西借用），我们都可以自由地移到新地方。\n', '\n', '然而，在 C 中，情况并不总是这样。一个类型在 C 中依赖于它的内存地址保持常量是相当常见的。例如，它可能包含一个指向它自己的指针，或者在某些全局数据结构中存储一个指向它自己的指针。在这种情况下，把它移到一个新的位置可能会产生未定义的行为。\n', '\n', '我们讨论过的 pthread 类型没有保证它们是可移动的，这在 Rust 中成为了一个相当大的问题。即使是一个简单的习语化的 Mutex::new() 函数也是个问题：它会返回一个互斥体对象，这将把它移到内存中的一个新位置。\n', '\n', '由于用户总是可以移动他们拥有的任何互斥体对象，我们要么需要让他们承诺他们不会这样做，通过制定一个不安全的接口；要么我们需要拿走他们的所有权并把所有东西隐藏在一个包装器后面（std::pin::Pin可以用于这个目的）。这两种都不是好的解决方案，因为他们会影响我们互斥体类型的接口，使得它变得非常容易出错和/或不便使用。\n', '\n', '解决这个问题的一个方法是把互斥体放在一个盒子里。通过把 pthread 互斥体放在它自己的分配器中，即使它的所有者被移动了，它在内存中的位置依然是一样的。\n', '\n', 'pub struct Mutex {\n', '    m: Box<UnsafeCell<libc::pthread_mutex_t>>,\n', '}\n', '\n', '这就是在 Rust 1.62 之前，在所有的 Unix 平台上，std::sync::Mutex 是如何实现的。\n', '\n', '这种方法的缺点是开销：现在每个互斥体都得到了它自己的分配，这给创建、销毁和使用互斥体带来了显著的开销。另一个缺点是它阻止了新的函数成为 const，这阻碍了有一个静态互斥体。\n', '\n', '即使 pthread_mutex_t 是可移动的，一个 const fn new 只能有默认的设置来初始化它，这会在递归锁定时导致未定义的行为。没有办法设计一个安全的接口来防止递归锁定，所以这意味着我们需要使锁定函数不安全，以让用户承诺他们不会做那样的事。\n', '\n', '在我们的 Box 方案中还剩下一个问题，就是在删除一个已经上锁的互斥体时发生的情况。似乎，通过合理的设计，这是不可能在还有锁的时候删除一个 Mutex，因为在它还被 MutexGuard 借用的时候就不能删除它了。 MutexGuard 必须先删除，才能解锁 Mutex。然而，在 Rust 中，忘记（或 泄漏）一个对象，不删除它，是安全的。这意味着可以写出这样的代码：\n', '\n', 'fn main() {\n', '    let m = Mutex::new(..);\n', '\n']['    let guard = m.lock(); // 锁定它 ..\n', "    std::mem::forget(guard); // .. 但不要解锁它。\n", '}\n', '\n', '在上面的示例中，m会在范围结束的时候被丢弃，而它还处于锁定状态。根据Rust编译器，这是可以接受的，因为守卫已经泄漏，无法再使用。\n', '\n', '然而，pthread规定，对一个已锁定的互斥量调用pthread_mutex_destroy()并不能保证能够成功，并可能导致未定义的行为。一种解决方法是，首先尝试锁定（并解锁）pthread互斥器，然后在尝试锁定（或者泄漏Box）时，如果已经被锁定，就会产生更多的开销。\n', '\n', '这些问题不仅适用于pthread_mutex_t，也适用于我们讨论过的其他类型。总的来说，pthread的同步机制对C来说很好，但对Rust来说不是很合适。\n', 'Linux\n', '\n', '在Linux系统中，pthread的同步机制都是通过futex系统调用实现的。它的名字来自于"fast user-space mutex"，因为最初添加这个系统调用的目的就是为了让库（比如pthread实现）包含一个快速且高效的互斥器实现。但是，它的功能比这个更强大，可以用于构建许多不同的同步工具。\n', '\n', 'Futex系统调用在2003年被添加到Linux内核，并且自那时以来已经进行了多次改进和扩展。其他一些操作系统也已添加了类似的功能，尤其是2012年Windows 8添加了WaitOnAddress（我们稍后会在"Windows"中讨论）。在2020年，C++语言甚至在其标准库中添加了对基本futex-like操作的支持，随着atomic_wait和atomic_notify函数的添加。\n', 'Futex\n', '\n', '在Linux上，SYS_futex是一个实现了各种操作的系统调用，这些操作都是在一个32位的原子整数上进行的。主要的两个操作是FUTEX_WAIT和FUTEX_WAKE。等待操作会使一个线程进入睡眠状态，而在同一个原子变量上的唤醒操作会唤醒该线程。\n', '\n', '这些操作并不在原子整数中存储任何东西。相反，内核记住了哪些线程在等待哪个内存地址，以便唤醒操作能唤醒正确的线程。\n', '\n', '在"等待：停车和条件变量"的第1章中，我们看到如何阻塞和唤醒线程的其他机制需要一种方法来确保唤醒操作在竞争中不会丢失。对于线程停车，这个问题是通过使unpark()操作也应用于未来的park()操作来解决的。而对于条件变量，那是由与条件变量一起使用的互斥器来负责的。\n', '\n', '对于futex的等待和唤醒操作，使用了另一种机制。等待操作接受一个参数，指定我们期望原子变量具有的值，并且如果它不匹配，就会拒绝阻塞。等待操作相对于唤醒操作是原子的，也就是说，在检查预期值和实际进入睡眠的时刻之间，没有唤醒信号可以丢失。\n', '\n', '如果我们确保在唤醒操作之前改变原子变量的值，我们就可以确保一个即将开始等待的线程不会进入睡眠，这样就不用关心可能错过futex唤醒操作的问题了。\n', '\n', '让我们通过一个简单的示例来实践一下。\n', '\n', '首先，我们需要能够调用这些系统调用。我们可以使用libc库的syscall函数来做到这一点，并将每个调用都包装在一个方便的Rust函数中，如下所示:\n', '\n', '#[cfg(not(target_os = "linux"))]\n', 'compile_error!("Linux only. Sorry!");\n', '\n', 'pub fn wait(a: &AtomicU32, expected: u32) {\n', '    // 参考futex（2）的man页了解系统调用的签名。\n', '    unsafe {\n', '        libc::syscall(\n', '            libc::SYS_futex, // The futex syscall.\n', '            a as *const AtomicU32, // The atomic to operate on.\n', '            libc::FUTEX_WAIT, // The futex operation.\n', '            expected, // The expected value.\n', '            std::ptr::null::<libc::timespec>(), // No timeout.\n', '        );\n', '    }\n', '}\n', '\n', 'pub fn wake_one(a: &AtomicU32) {\n', '    // 参考futex（2）的man页了解系统调用的签名。\n', '    unsafe {\n', '        libc::syscall(\n', '            libc::SYS_futex, // The futex syscall.\n', '            a as *const AtomicU32, // The atomic to operate on.\n', '            libc::FUTEX_WAKE, // The futex operation.\n', '            1, // The number of threads to wake up.\n', '        );\n', '    }\n', '}\n', '\n', '现在，作为一个使用示例，我们来使用这些功能让一个线程等待另一个线程。我们会使用一个我们初始化为零的原子变量，主线程会在这个变量上进行futex等待。第二个线程会把变量改为1，并在其上进行一个futex唤醒操作，以唤醒主线程。\n', '\n', '就像线程停车和等待条件变量一样，futex等待操作可能会在没有发生任何事情的情况下突然唤醒。因此，它最常用的方式是在一个循环中，如果我们正在等待的条件还没有被满足，就重复这个操作。\n', '\n', '让我们看一下下面的示例：\n', '\n', 'fn main() {\n', '    let a = AtomicU32::new(0);\n', '\n', '    thread::scope(|s| {\n', '        s.spawn(|| {\n', '            thread::sleep(Duration::from_secs(3));\n', '            a.store(1, Relaxed); 1\n', '            wake_one(&a); 2\n', '        });\n', '\n', '        println!("Waiting...");\n', '        while a.load(Relaxed) == 0 { 3\n', '            wait(&a, 0); 4\n', '        }\n', '        println!("Done!");\n', '    });\n', '}\n', '\n', '1\t\n', '\n', '生成的线程将在几秒钟后把原子变量设为一。\n', '2\t\n', '\n', '然后它执行一个futex唤醒操作来唤醒主线程，以防它正在睡眠，所以可以看到变量已经改变了。\n', '3\t\n', '\n', '主线程等待变量为零，直到继续打印它的最终消息。\n', '4\t\n', '\n', 'futex等待操作被用来使线程进入睡眠。非常重要的一点，这个操作在进入睡眠之前会检查a是否仍然是零，这是在3和4之间嵌入线程信号不能丢失的原因。要么1（因此是2）还没有发生，它就会进入休眠，要么1（可能是2）已经发生，它就会立即继续。\n', '\n', '这里需要注意的一点是，如果a在while循环前已经被设置为1，那么等待调用就完全被避免了。以类似的方式，如果主线程也在原子变量中存储它是否开始等待信号（通过将它设置为一个不等于零或一的值），那么信号线程可以跳过futex唤醒操作，如果主线程还没有开始等待。这就是futex基的同步原语如此快的原因：由于我们自己管理状态，我们不需要依赖内核，除非我们实际需要阻塞。\n', '\n', '自从Rust 1.48以来，标准库的线程停车功能在Linux上就像这样实现的。它们对每个线程使用一个原子变量，有三种可能的状态：零表示空闲和初始状态，一表示"解阻但尚未停车"，负一表示"已停车但尚未解阻"。\n', '\n', '在第9章中，我们将使用这些操作来实现互斥器、条件变量和读写锁。\n']['Futex操作\n', '\n', '除了wait和wake操作之外，futex系统调用还支持其他几种操作。在本节中，我们将简短地讨论这个系统调用支持的所有操作。\n', '\n', '对futex的第一个参数总是一个指向要操作的32位原子变量的指针。第二个参数是表示操作的常量，比如FUTEX_WAIT，可以添加最多两个标志：FUTEX_PRIVATE_FLAG和/或FUTEX_CLOCK_REALTIME，我们将在下文中讨论。剩余的参数依赖于操作，并且会在下文的各项操作中进行描述。\n', '\n', 'FUTEX_WAIT\n', '\n', '    这个操作需要两个额外的参数：原子变量预期的值和表示最大等待时间的timespec的指针。\n', '\n', '    如果原子变量的值与预期值相匹配，wait操作会阻塞，直到被wake操作唤醒，或者timespec指定的时间过去。如果timespec的指针为null，那么就没有时间限制。另外，wait操作可能会在达到时间限制之前，没有相应的wake操作，就会自发地唤醒并返回。\n', '\n', '    检查和阻塞操作在相对于其他futex操作时，作为一个单一的原子操作执行，这意味着没有唤醒信号可以在它们之间丢失。\n', '\n', '    由timespec指定的持续时间默认表示了一个单调时钟（如Rust的Instant）。通过添加FUTEX_CLOCK_REALTIME标志，将使用实时时钟（如Rust的SystemTime）。\n', '\n', '    返回值指示预期的值是否匹配，以及是否达到超时。\n', 'FUTEX_WAKE\n', '\n', '    这个操作需要一个额外的参数：要唤醒的线程数，以i32表示。\n', '\n', '    这将唤醒指定数量的线程，这些线程在相同的原子变量上进行wait操作。 （或者，如果没有那么多等待的线程，唤醒较少的线程。）最常见的，这个参数要么是一个，唤醒一个线程，或者是i32::MAX，唤醒所有线程。\n', '\n', '    返回值是唤醒的线程数。\n', 'FUTEX_WAIT_BITSET\n', '\n', '    这个操作需要四个额外的参数：原子变量预期的值，表示最大等待时间的timespec的指针，被忽略的指针，以及一个32位的"位集"（一个u32）。\n', '\n', '    这个操作与FUTEX_WAIT的操作相同，只是有两个不同之处。\n', '\n', '    第一个不同之处是它接受一个位集参数，可以用来等待只有特定wake操作，而不是在同一个原子变量上的所有wake操作。FUTEX_WAKE操作永远不会被忽略，但是如果wait位集和wake位集没有任何1位是共享的，那么来自FUTEX_WAKE_BITSET操作的信号就会被忽略。\n', '\n', '    例如，一个带有0b0101位集的FUTEX_WAKE_BITSET操作会唤醒一个带有0b1100位集的FUTEX_WAIT_BITSET操作，但不会唤醒一个带有0b0010位集的操作。\n', '\n', '    当实现像读写锁这样的东西时，这可能很有用，可以唤醒写者而不唤醒任何读者。然而，注意，使用两个独立的原子变量比使用一个用于两种不同类型的等待者的变量更有效，因为内核会为每个原子变量保持一份等待者列表。\n', '\n', '    与FUTEX_WAIT的另一个不同之处是，timespec被用作绝对时间戳，而非持续时间。因为这个原因，FUTEX_WAIT_BITSET经常会与u32::MAX的位集（所有位均设置）一起使用，有效地将其变为一个常规的FUTEX_WAIT操作，但是对于时间限制，使用的是绝对时间戳。\n', 'FUTEX_WAKE_BITSET\n', '\n', '    这个操作需要四个额外的参数：要唤醒的线程数，两个被忽略的指针，以及一个32位的"位集"（一个u32）。\n', '\n', '    这个操作与FUTEX_WAKE完全相同，除了它不会唤醒那些位集不重叠的FUTEX_WAIT_BITSET操作。（参见上文的FUTEX_WAIT_BITSET。）\n', '\n', '    如果位集为u32::MAX（所有位都被设置），那么这与FUTEX_WAKE相同。\n', 'FUTEX_REQUEUE\n', '\n', '    这个操作需要三个额外的参数：要唤醒的线程数（一个i32），要重新排队的线程数（一个i32），以及第二个原子变量的地址。\n', '\n', '    这个操作唤醒了给定的等待线程数，然后将剩余等待线程数重新排队，以在另外一个原子变量上等待。\n', '\n', '    被重新排队的等待线程将继续等待，但是不再受主原子变量的唤醒操作影响。取而代之的是，它们现在由次要原子变量的唤醒操作唤醒。\n', '\n', '    这可能非常有用，可以用来实现像条件变量的"全部通知"操作。而不是唤醒所有线程，它们随后会试图锁定一个互斥锁，最有可能会使得除了一个线程之外的所有线程立刻等待那个互斥锁，我们可以只唤醒一个线程并且将其他所有的线程重新排队，让他们直接等待互斥锁而不是首先唤醒他们。\n', '\n', '    就如同FUTEX_WAKE操作一样，可以使用i32::MAX的值来重新排队所有等待的线程。 （对于要唤醒的线程数指定一个i32::MAX的值并不是那么有用，因为这会使这个操作变成等于FUTEX_WAKE。）\n', '\n', '    返回唤醒的线程数。\n', '\n', 'FUTEX_CMP_REQUEUE\n', '\n', '    这个操作需要四个额外的参数：要唤醒的线程数（一个i32），要重新排队的线程数（一个i32），第二个原子变量的地址，以及主原子变量预期的值。\n', '\n', '    这个操作几乎与FUTEX_REQUEUE完全相同，只是如果主原子变量的值不与预期值匹配，那么它会拒绝操作。表检查值和重新排队操作会在相对于其他futex操作时，作为一个原子操作执行。\n', '\n', '    与FUTEX_REQUEUE不同的是，这会返回唤醒和重新排队线程数的总和。\n', 'FUTEX_WAKE_OP\n', '\n', '    这个操作需要四个额外的参数：要在主原子变量上唤醒的线程数（一个i32），可能在第二个原子变量上唤醒的线程数（一个i32），第二个原子变量的地址，以及编码了要进行的一个操作和一个比较的32位值。\n', '\n', '    这是一个非常专门的操作，它修改次要原子变量，唤醒在主原子变量上等待的某些线程，检查原子变量的旧值是否满足给定条件，如果满足，也会在次要原子变量上唤醒一些线程。\n', '\n', '    换句话说，它与以下代码相同，只不过整个操作在相对于其他futex操作时，作为原子进行：\n', '\n', '    let old = atomic2.fetch_update(Relaxed, Relaxed, some_operation);\n', '    wake(atomic1, N);\n', '    if some_condition(old) {\n', '        wake(atomic2, M);\n', '    }\n', '\n', '    要执行的修改操作和要检查的条件都由syscall的最后一个参数指定，编码在其32位中。操作可以是以下之一：赋值，加法，二进制或，二进制与非，二进制异或，使用一个12位参数或者一个32位参数，取自两的幂。比较可以选择为==，!=，<，<=，>，和>=，带一个12位参数。\n', '\n', '    有关这个参数的编码详细信息，可以查看futex（2）Linux手册页，或者使用crates.io上的linux-futex库，这个库包含了一个方便方式来构造这个参数。\n', '\n', '    这个操作返回唤醒线程的总数。\n', '\n', '    乍一看这可能像是一个灵活的操作，有很多用途。然而，它是为GNU libc中的一个特定用例设计的，其中两个线程必须从两个独立的原子变量被唤醒。那个特定的情况已经被另一个实现所替代，这个新的实现不再使用FUTEX_WAKE_OP。\n', '\n', 'FUTEX_PRIVATE_FLAG可以添加到任何这些操作中，以启用一个可能的优化，如果所有在相同的原子变量/变量组上的重要futex操作都来自同一进程的线程，这通常是常见的情况。为了利用它，每个重要的futex操作都需要包括这个相同的标志。通过允许内核假定不会有与其他进程的互动，它可以跳过在执行futex操作时一些可能的昂贵步骤，从而提升性能。\n', '\n', '除了Linux，NetBSD也支持所有上述的futex操作。OpenBSD也有一个futex系统调用，但只支持FUTEX_WAIT，FUTEX_WAKE，和FUTEX_REQUEUE操作。FreeBSD并没有原生的futex系统调用，但是确实包括一个名为_umtx_op的系统调用，它包括了与FUTEX_WAIT和FUTEX_WAKE几乎相同的功能：UMTX_OP_WAIT（对于64位原子），UMTX_OP_WAIT_UINT（对于32位原子），和UMTX_OP_WAKE。Windows也包括了一些行为非常类似于futex wait和wake操作的函数，我们将在本章后面讨论。\n', '新的Futex操作\n', '\n', '截止到2022年发布的Linux 5.16，还有一个新的futex系统调用：futex_waitv。这个新的系统调用允许一次等待多个futex，通过提供一个原子变量的列表（和它们预期的值）来等待。被futex_waitv阻塞的线程可以通过任何指定变量的wake操作来唤醒。\n', '\n', '这个新的系统调用也为未来的扩展留下了空间。例如，它可以指定要等待的原子变量的大小。虽然初始的实现只支持32位原子，就像原来的futex系统调用一样，但未来可能会扩展到支持8位，16位，和64位的原子。\n', '优先级继承Futex操作\n', '\n', '优先级反转是一个问题，发生在一个高优先级线程被低优先级线程持有的锁阻塞的时候。高优先级线程实际上已经被其优先级"反转"，因为它现在必须等待低优先级线程释放锁才能继续进行。\n', '\n', '这个问题的解决方案是优先级继承，在这种情况下，阻塞的线程继承了它等待的最高优先级线程的优先级，暂时地提高了低优先级线程在持有锁的时候的优先级。\n']['\n', '除了我们之前讨论的七种futex操作，还有六种专门设计用来实现优先级继承锁的优先级继承futex操作。', '\n', '我们之前讨论的通用futex操作并不对原子变量的具体内容有任何要求。我们可以自己选择32位表示什么。然而，对于一个优先级继承的互斥锁，内核需要能理解互斥锁是否被锁定，如果是，锁定它的是哪个线程。', '\n', '为了避免每次状态变化都必须发出系统调用，优先级继承的futex操作指定了32位原子变量的确切内容，所以内核可以理解：最高位表示是否有任何线程等待锁定互斥锁，最低的30位包含持有锁的线程的线程ID（Linux tid，不是Rust ThreadId），或者当解锁时为零。', '\n', '作为一个额外的特性，如果持有锁的线程在未解锁的情况下终止，但只在有等待者的情况下，内核会设置第二高位。这允许互斥锁健壮：一种用来描述互斥锁可以优雅处理其“拥有”的线程意外终止的情况的术语。', '\n', '优先级继承的futex操作与标准的互斥锁操作一一对应：FUTEX_LOCK_PI用于锁定，FUTEX_UNLOCK_PI用于解锁，而FUTEX_TRYLOCK_PI用于在无阻塞的情况下锁定。此外，FUTEX_CMP_REQUEUE_PI和FUTEX_WAIT_REQUEUE_PI操作可以用来实现与优先级继承互斥锁配套的条件变量。', '\n', '我们不会详细讨论这些操作。有关它们的详细内容，请参阅futex(2) Linux man页面或crates.io上的linux-futex包。', 'macOS\n', '\n', '作为macOS的一部分的内核支持各种有用的低级并发相关的系统调用。然而，就像大多数操作系统一样，内核接口不被认为是稳定的，我们不应该直接使用它。', '\n', '软件应该通过系统附带的库与macOS内核交互。这些库包括其C( libc)、C++ (libc++)、Objective-C和Swift的标准库实现。', '\n', '作为符合POSIX的Unix系统，macOS的C库包括完整的pthread实现。其他语言的标准锁定通常趋向使用pthread的原语。', '\n', '相比于其他操作系统上的等效锁，Pthread的锁在macOS上相对较慢。其中一个原因是macOS上的锁默认为公平锁。这意味着当多个线程试图锁定同一个互斥锁时，它们按到达的顺序被服务，就像一个完美的队列。虽然公平性可取，但在高竞争下它可能会大幅降低性能。', 'os_unfair_lock\n', '\n', '除了pthread原语，macOS 10.12引入了一个新的轻量级平台特定的不公平互斥锁：os_unfair_lock。它只有32位大小，以OS_UNFAIR_LOCK_INIT常量静态初始化，不需要销毁。通过os_unfair_lock_lock()（阻塞）或os_unfair_lock_trylock()（非阻塞）进行加锁，通过os_unfair_lock_unlock()解锁。', '\n', '遗憾的是，它没有附带条件变量，也没有读写者变量。', 'Windows\n', '\n', 'Windows操作系统附带了一套库，它们一起形成了Windows API，通常被称为"Win32 API"（即使在64位系统上）。它在"Native API"之上形成一层：这是一个大部分未经记录的与内核的接口，我们不应直接使用它。', '\n', 'Windows API通过Microsoft官方的windows和windows-sys包在crates.io上提供给Rust程序。', '重量级内核对象\n', '\n', 'Windows上可用的许多早期同步原语都完全由内核管理，使它们相当重量级，并赋予它们与其他内核管理的对象，如文件，相似的属性。他们可以被多个进程使用，可以通过名字命名和定位，他们支持细粒度的权限，类似于文件。例如，它可以允许一个进程等待一些对象，而不允许它通过发送信号唤醒其他人。', '\n', '这些重量级内核管理的同步对象包括Mutex（可以锁定和解锁），Event（可以发信号和等待)，以及WaitableTimer（在选定的时间后自动发信号，或周期性）。创建这样一个对象会产生一个HANDLE，就像打开一个文件一样，可以容易地传递和使用常规HANDLE函数；最值得注意的是等待函数系列。这些函数允许我们等待一个或多个不同类型的对象，包括重量级同步原语，进程，线程，以及各种IO形式。', '轻量级对象\n', '\n', '在Windows API中包含的一种轻量级同步原语是"临界区"。", '\n', '术语临界区指的是程序的一部分，可能有多个线程并发进入的一个"区域"。保护临界区的机制通常被称为互斥锁。在这种情况下，微软可能使用了名为"临界区"的机制，就是因为"互斥锁"的名字已经被上面讨论的重量级Mutex对象所占用。", '\n', 'Windows CRITICAL_SECTION实际上是一个递归的互斥锁，只是它使用了"enter"和"leave"的术语，而不是"lock"和"unlock"。作为一个递归的互斥锁，它设计的主要是保护其他线程。它允许同一个线程多次锁定（或"进入"）它，要求它也解锁（离开）相同的次数。", '\n', '当你在Rust中包装这种类型时，要牢记这一点。成功锁定（进入）一个CRITICAL_SECTION不应该导致对由其保护的数据的独占引用（&mut T）。否则，一个线程可能会使用这个来创建两个对同一数据的独占引用，这马上就会导致未定义的行为。", '\n', 'CRITICAL_SECTION使用InitializeCriticalSection()函数初始化，使用DeleteCriticalSection()函数销毁，并且不能被移动。通过EnterCriticalSection()或TryEnterCriticalSection()进行锁定，通过LeaveCriticalSection()解锁。', '\n', '直到Rust 1.51，Windows XP上std::sync::Mutex都是基于一个因子分配的CRITICAL_SECTION对象。（Rust 1.51将对Windows XP的支持取消）\n', '轻量级读者-写者锁\n', '\n', '从Windows Vista（和Windows Server 2008）开始，Windows API包括了一个非常好的、轻量级锁定原语：SRW锁，简称SRW锁。\n', '\n', 'SRWLOCK类型只有一个指针大小，可以用SRWLOCK_INIT静态初始化，不需要销毁。尽管没有在使用（借用）时，我们甚至允许移动它，使得它可以成为在Rust类型中包装的绝佳候选对象。', '\n', '它通过AcquireSRWLockExclusive()，TryAcquireSRWLockExclusive()，和ReleaseSRWLockExclusive()提供了独占（写）锁定和解锁，通过AcquireSRWLockShared()，TryAcquireSRWLockShared()，和ReleaseSRWLockShared()提供共享（读）锁定和解锁。它通常用作一个常规的互斥锁，只是忽略了共享（读）锁定函数。', '\n', 'SRW锁既不优先考虑写者也不优先考虑读者。虽然不能保证，但它尽可能地按顺序为所有锁请求提供服务，以尽可能不降低性能。一个线程不能试图在一个已经持有一个的线程上获取第二个共享（读）锁。如果这样做可能会导致永久的死锁，如果操作被另一个线程的独占（写）锁操作排在后面，然后被第一个线程已经持有的第一个共享（读）锁阻塞。', '\n', '当引入条件变量时，SRW锁被同时引入到Windows API中。类似于一个SRW锁，CONDITION_VARIABLE只有一个指针大小，可以用CONDITION_VARIABLE_INIT静态初始化，不需要销毁。只要没有在使用（借用），我们也允许移动它', '\n', '这个条件变量不仅可以与一个SRW锁一起使用，通过SleepConditionVariableSRW，也可以与一个关键段一起使用，通过SleepConditionVariableCS。', '\n', '唤醒等待的线程是通过WakeConditionVariable来唤醒一个线程，或通过WakeAllConditionVariable来唤醒所有等待的线程。', '\n', '原来在标准库中使用的Windows SRW锁和条件变量都被包装在一个Box中，以避免移动对象。直到2020年我们要求Microsoft披露可移动性保证后，Microsoft才对这个进行文档化。自那时起，从Rust 1.49开始，std::sync::Mutex，std::sync::RwLock，和std::sync::Condvar在Windows Vista和以后版本上直接包装了一个SRWLOCK或CONDITION_VARIABLE，没有任何的分配。', '基于地址等待\n', '\n', 'Windows 8（和Windows Server 2012）引入了一种新的、更灵活的同步功能类型，它与我们在本章早些时候讨论的Linux FUTEX_WAIT和FUTEX_WAKE操作非常相似。', '\n', 'WaitOnAddress函数可以操作一个8位的，16位的，32位的，或64位的原子变量。它需要四个参数：原子变量的地址，持有期望值的变量的地址，原子变量的大小（以字节为单位），以及在放弃前最大等待的毫秒数（或u32::MAX表示无限超时）。', '\n', '就像FUTEX_WAIT操作一样，它将原子变量的值与期望值进行比较，如果匹配，就会睡眠，等待一个对应的唤醒操作。检查和睡眠的操作与唤醒的操作是原子的，这意味着唤醒的信号在中间不能丢失。', '\n', '唤醒一个等待WaitOnAddress的线程是通过WakeByAddressSingle来唤醒一个线程，或通过WakeByAddressAll来唤醒所有等待的线程。这两个函数只需要一个参数：也就是传递给WaitOnAddress的原子变量的地址。', '\n', 'Windows API中的一些，但并非所有，同步原语都使用这些函数来实现。更重要的是，它们是构建我们自己的原语的伟大的构建块，我们将在第9章中进行讨论。', '总结\n', '\n', '    系统调用是一种进入操作系统内核的调用，相比于普通的函数调用，它相对慢。\n', '\n', '    通常，程序不直接进行系统调用，而是通过操作系统的库（例如libc)与内核进行交互。在许多操作系统上，这是与内核进行交互的唯一支持的方式。\n', '\n', '    libc包给Rust代码提供访问libc的机会。\n', '\n', '    在POSIX系统中，libc包含的内容比C标准要求的更多，以符合POSIX标准。\n', '\n', '    POSIX标准包括pthreads，一种包含并发原语例如pthread_mutex_t的库。\n', '\n', '    Pthread类型是为C设计的，而不是为Rust设计的。例如，它们是不可移动的，这可能存在问题。\n', '\n', '    Linux有支持数种等待和唤醒操作的futex系统调用。等待操作验证原子期望值，这用于避免错过通知。\n', '\n', '    除了pthreads，macOS还提供了os_unfair_lock作为轻量级的锁定原语。\n', '\n', '    Windows重量级并发原语总是需要与内核交互，但可以在进程间传递，可用于标准Windows等待函数。\n', '\n', '    Windows轻量级并发原语包括一个“slim”读者-写者锁（SRW lock）和一个条件变量。这些易于在Rust中包装，因为它们可以移动。\n', '\n', '    Windows还提供基本的像futex那样的功能，通过WaitOnAddress和WakeByAddress。\n']
