['第十章. 灵感和想法\n', '\n', '并发相关的主题、算法、数据结构、轶事以及其他可能成为本书章节的内容是无穷无尽的。然而，我们已经到了最后一章，我们也快要分别了，希望你将以充满激情的心情期待新的可能性，并准备在实践中应用新的知识和技能。\n', '\n', '本章的目的是通过向你展示一些你可以研究、探索并自行建立的想法，为你自己的创新和未来的工作提供灵感。\n', '信号量\n', '\n', '信号量实际上只是一个计数器，有两个操作：信号（也被称为上或V）和等待（也被称为下或P）。信号操作将计数器增加到一定的最大值，而等待操作则减少计数器。如果计数器为零，等待操作将阻塞并等待匹配的信号操作，防止计数器变为负数。它是一种灵活的工具，可以用来实现其他同步原语。\n', "信号量的可视化。一条看似无穷的带有整数的条带，从零开始，负数位置标有'阻塞'。一个大箭头正在指向零，但可以通过等待和信号操作在左右移动。\n", '\n', '信号量可以用Mutex<u32>实现计数器和用Condvar实现等待操作进行实现。然而，有多种更有效的实现方式。最值得注意的是，在支持futex-like操作的平台上("Futex"在第8章)，它可以被更高效地实现为一个单一的AtomicU32（甚至AtomicU8）。\n', '\n', '一个最大值为1的信号量有时被称为二元信号量，可以用作构建其他原语的基础块。例如，它可以被初始化为1作为互斥量使用，使用等待操作进行锁定，使用信号操作进行解锁。通过将其初始化为零，它也可以用于信号，就像一个条件变量。例如，std::thread中的标准park()和unpark()函数可以被实现为与线程相关的二元信号量上的等待和信号操作。\n', '\n', '注意，一个互斥量可以用信号量来实现，而一个信号量可以用互斥量（和条件变量）来实现。建议避免使用基于互斥量的信号量来实现基于信号量的互斥量，反之亦然。\n', '\n', '进一步阅读：\n', '\n', '    维基百科关于信号量的文章\n', '\n', '    斯坦福大学关于信号量的课程笔记\n', '\n', 'RCU\n', '\n', '如果你想允许多个线程（大多数情况下）读取并（有时）修改一些数据，你可以使用RwLock。当这个数据只是一个单独的整数时，你可以使用一个原子变量（如AtomicU32）来避免锁定，这更有效率。然而，对于更大的数据块，比如一个有许多字段的struct，没有可用的原子类型可以在整个对象上进行无锁原子操作。\n', '\n', '就像计算机科学中的每一个问题一样，这个问题可以通过添加一层间接性来解决。你可以使用一个原子变量来存储它的指针，而不是struct本身。这仍然无法让你原子化地修改整个struct，但它确实允许你原子化地替换整个struct，这几乎同样好。\n', '\n', '这种模式通常被称为RCU，代表"读取、复制、更新"，这是替换数据所需要的步骤。读取指针后，struct可以被复制到一个新的分配中，这样可以在不担心其他线程的情况下修改。准备好后，可以使用比较-交换操作（"比较-交换操作"在第2章）来更新原子指针，但只有在其他线程没有在此期间替换数据的情况下，这个操作才会成功。\n', 'RCU模式的可视化显示了五个步骤。步骤1，读取，显示了一个箭头从原子指针到它所指向的struct。步骤2，复制，将整个struct复制到一个新的分配中。步骤3，修改，修改了复制的一个字段。步骤4，更新，是一个比较-交换操作，用来更新原子指针指向新分配的复制。步骤5，释放，释放原始struct，但这个步骤被灰出并带有一个问号。\n', '\n', 'RCU模式最有趣的部分是最后一个步骤，它不包含在首字母缩写中：释放旧数据。在成功更新数据后，其他线程可能仍在读取旧复制，如果它们在更新前阅读了指针。你必须等待这些线程完成后，才能释放旧的复制。\n', '\n', '有许多可能的解决方案，包括引用计数（像Arc那样），内存泄漏（忽略问题），垃圾回收，危险指针（线程告诉其他线程它们当前正在使用什么指针的一种方式），以及静止状态追踪（等待每个线程达到一个肯定不使用任何指针的点）。在某些条件下，最后一项可以非常有效。\n', '\n', 'Linux内核中的许多数据结构都是基于RCU的，关于它们的实现细节有许多有趣的演讲和文章，可以提供很多灵感。\n', '\n', '进一步阅读：\n', '\n', '    维基百科关于读-复制-更新模式的文章\n', '\n', '    LWN关于"什么是RCU,基本上？"的文章\n', '\n', '无锁链表\n', '\n', '在基本的RCU模式上进行扩展，你可以在struct中添加一个原子指针以指向下一个，以将其转为链表。这使得线程能够原子地在这个列表中添加或删除元素，而无需为每次更新复制整个链表。\n', '\n', '要在列表开始处插入一个新元素，你只需要分配该元素并指向列表中的第一个元素，然后原子地更新最初的指针以指向你新分配的元素。\n', '在链表中插入第四个节点的过程的可视化，由三个步骤组成。步骤1，阅读，显示了一个箭头从原子指针指向第一个节点。步骤2，创建，是分配和创建一个新节点，该节点指向步骤1中的第一个节点。步骤3，更新，是一个比较交换操作，用来更新第一个原子指针以指向新创建的节点。\n', '\n', '同样，删除元素可以通过原子更新前面的指针以指向后面的元素来完成。然而，当涉及到多个写入者时，必须小心处理在相邻元素上的并发插入或删除操作。否则，你可能无意间也删除了一个并发新插入的元素，或撤销了一个并发删除的元素的删除。\n', '\n', '为了保持简单，你可以使用普通的互斥量来避免并发的变化。这样，阅读仍是一个无锁操作，但你无需担心处理并发变化。\n', '\n', '从链表中拆分一个元素后，你将面临之前的同一问题：等待你可以释放它（或以其他方式声明所有权）。我们在基本的RCU模式中讨论过的同样的解决方案在这种情况下也可以有效。\n', '\n', '一般来说，你可以基于原子指针上的比较-交换操作构建各种复杂的无锁数据结构，但你总是需要一个良好的策略来释放或以其他方式重新取得分配的所有权。\n', '\n', '进一步阅读：\n', '\n', '    维基百科关于无阻塞链表的文章\n', '\n', '    LWN关于"使用RCU进行链表操作——案例研究"的文章\n', '\n', '基于队列的锁\n', '\n', '对于大多数标准锁定原语，操作系统的内核会跟踪被它阻塞的线程，并负责在被要求时唤醒一个线程。一个有趣的替代方案是通过手动跟踪等待线程的队列来实现一个互斥量（或其他锁定原语）。\n', '\n', '互斥量可以实现为一个AtomicPtr，这个指针可以指向一个（列表）等待的线程。\n', '\n', '这个列表中的每个元素都需要包含某种可以用来唤醒相应线程的东西，比如一个std::thread::Thread对象。原子指针的一些未使用的位可以用来存储互斥量本身的状态，以及管理队列状态所必需的东西。\n', "基于队列的锁的可视化。锁是一个原子指针，其中最后两位被标记为'互斥锁定'和'队列锁定'。指针的其余部分指向队列，一个由三个节点组成的单链表，其中每个节点都包含一个Thread对象。\n", '\n', '有许多可能的变型。队列可以被其自己的锁位保护，或者可以被实现为一个（部分）无锁结构。元素不需要被分配在堆上，但可以是正在等待的线程的局部变量。队列可以是一个双向链表，不仅有指向下一个元素的指针，也有指向上一个元素的指针。第一个元素也可以包括一个指向最后一个元素的指针，以便有效地在末尾添加一个元素。\n', '\n', '这种模式允许使用只需要一个可以用来阻塞和唤醒单个线程的东西（如线程挂起）来实现有效的锁定原语。\n', '\n', 'Windows SRW锁（"Slim reader-writer locks"在第8章）就是使用这种模式来实现的。\n', '\n', '进一步阅读：\n', '\n', '    关于Windows SRW锁实现的笔记\n', '\n', '    基于队列的锁的Rust实现\n', '\n', '停车场式锁\n', '\n', '为了制定一个高效率且尽可能小的互斥量，你可以基于基于队列的锁的思想，将队列移动到全局的数据结构中，只在互斥量本身留下一两位。这样，互斥量只需一个字节。你甚至可以将其放在某个未使用的指针位中，以此实现非常精细的锁定操作，几乎不需要额外的开销。\n', '\n', '全局数据结构可以是一个HashMap，它将内存地址映射到等待在该地址的互斥量的线程队列。这个全局数据结构通常被称为停车场，因为它是一些暂停线程的集合。\n', "一个互斥量和停车场的可视化。互斥量是一个AtomicU8，它的最后两位被标记为'锁定'和'有队列'。其余的是零。停车场由一个HashMap组成，它将互斥量的地址映射到一队Thread对象。\n", '\n', '该模式可以通过不仅追踪互斥量的队列，而且追踪条件变量和其他原语的队列进行推广。通过追踪任何原子变量的队列，这有效地提供了一种在不支持该功能的平台上实现futex-like功能的方法。\n', '\n', '该模式最著名的是其在2015年在WebKit中的实现，其中它被用于锁定JavaScript对象。其实现启发了其他实现，如流行的parking_lot Rust crate。\n', '\n', '进一步阅读：\n', '\n', '    WebKit博客文章，"WebKit中的锁定"\n', '\n']['    parking_lot crate的文档\n', '\n', '序列锁\n', '\n', '序列锁是另一种解决原子更新（较大）数据问题的解决方案，无需使用传统的（阻塞）锁。它使用一个原子计数器，当数据正在更新时它为奇数，当数据准备好被读取时它为偶数。\n', '\n', '写线程必须在更改数据之前将计数器从偶数增加到奇数，然后再次增加计数器以使其保持在（不同的）偶数值。\n', '\n', '任何读线程都可以在任何时候、无需阻塞地读取数据，方法是在读取前后读取计数器。如果计数器的两个值相等并且为偶数，说明没有并发修改，这意味着您读取了数据的有效副本。否则，你可能读取了正在被并发修改的数据，在这种情况下你应该再试一次。\n', '序列锁的可视化，一个AtomicUsize后跟着一大块数据。写者有三个步骤：增加计数器，写数据，再次增加计数器。读者有四个步骤：读取计数器，读取数据，读取计数器，如果两次读取不一致或为奇数，则重试。\n', '\n', '这是一种非常好的模式，可以将数据对其他线程开放，而不可能让读线程阻塞写线程。它经常被用于操作系统内核和许多嵌入式系统。因为读取者只需要读取内存的访问权，并且不涉及指针，所以这可能是一种可以在共享内存中安全使用的数据结构，可以在进程之间使用，而不需要信任读取者。例如，Linux内核使用这种模式通过为进程提供只读访问（共享）内存的方式，非常高效地为进程提供时间戳。\n', '\n', '一个有趣的问题是如何将这种模式嵌入内存模型。同一数据的并发非原子读写会导致未定义的行为，即使忽略读到的数据也是如此。这意味着，从技术上讲，读取和写入数据只应使用原子操作，即使整个读或写不必是单一的原子操作。\n', '\n', '进一步阅读：\n', '\n', '    Linux的Seqlock的维基百科文章\n', '\n', '    Rust RFC 3301, AtomicPerByte\n', '\n', '    seqlock crate的文档\n', '\n', '教学材料\n', '\n', '花费很多时间——或者几年——发明新的并发数据结构并设计舒适的Rust实现可能会非常有趣。如果你在寻找其他方法来运用你在Rust, atomics, locks, concurrent data structures以及并发性方面的知识，那么创建新的教学材料并与他人分享你的知识可能会非常有益。\n', '\n', '针对这些话题的新手的可接触资源严重不足。Rust在让系统编程对所有人更容易访问方面发挥了重要作用，但是许多程序员仍然对低级别的并发保持谨慎。原子操作经常被认为是一种神秘的主题，最好由一小群专家来处理，这是一种遗憾。\n', '\n', '我希望这本书能进行重要的贡献，但是关于Rust并发的书籍、博客文章、文章、视频课程、会议讲座和其他材料还有很大的空间。 \n']