['第五章. 建立我们自己的通道\n', '\n', '通道可以用来在线程之间发送数据，并且有多种变体。一些通道只能在一个发送者和一个接收者之间使用，而另一些可以从任何数量的线程发送，甚至可以允许多个接收者。一些通道是阻塞的，意味着接收（有时也包括发送）是一个阻塞操作，使你的线程休眠，直到操作能够完成。一些通道优化了通过量，而另一些通道优化了低延迟。\n', '\n', '变化是无尽的，并且没有适合所有用例的一种尺寸适合所有的版本。\n', '\n', '在这一章，我们将实现几个相对简单的通道，不仅探索原子的更多应用，同时也了解更多关于我们的要求和假设如何能被Rust的类型系统捕获。\n', '简单的基于Mutex的通道\n', '\n', '一个基础的通道实现不需要任何原子的知识。我们可以把VecDeque，它基本上是一个Vec可以高效地添加和删除元素在两端，并用Mutex保护它以允许多线程访问。然后，我们使用VecDeque作为队列的数据，这通常被称为已经发送但尚未接收的消息。任何想要发送消息的线程只需将其添加到队列的后面，任何想要接收消息的线程只需从队列前面移除一个即可。\n', '\n', '只有再加一件事，它用来使接收操作成为阻塞：一个Condvar（见第1章的"条件变量"）来通知等待接收的新消息。\n', '\n', '这个的实现可以很短，也相对直接，如下所示：\n', '\n', 'pub结构体Channel<T> {\n', '    queue：互斥锁<VecDeque<T>>，\n', '    item_ready: Condvar，\n', '}\n', '\n', 'impl<T> Channel<T> {\n', '    pub fn new() -> Self {\n', '        Self {\n', '            queue：Mutex::new(VecDeque::new())，\n', '            item_ready：Condvar::new()，\n', '        }\n', '    }\n', '\n', '    pub fn send(&self, message: T) {\n', '        self.queue.lock().unwrap().push_back(message);\n', '        self.item_ready.notify_one();\n', '    }\n', '\n', '    pub fn receive(&self) -> T {\n', '        let mut b = self.queue.lock().unwrap();\n', '        loop {\n', '            if let Some(message) = b.pop_front() {\n', '                return message;\n', '            }\n', '            b = self.item_ready.wait(b).unwrap();\n', '        }\n', '    }\n', '}\n', '\n', '请注意，我们并未使用任何原子操作或不安全的代码，也不必考虑Send或Sync特性。编译器理解Mutex的接口以及该类型提供的保障，并将隐含地理解，如果Mutex<T>和Condvar都可以安全地在线程间共享，那么我们的Channel<T>也可以。\n', '\n', '我们的send函数锁定互斥体将新消息推到队列的后面，并在解锁队列后，通过使用条件变量直接通知一个可能正在等待的接收者。\n', '\n', '接收函数也会锁定互斥体，从队列前端弹出下一条消息，但如果还没有消息可用，会使用条件变量等待。\n', '\n', '请记住，Condvar::wait方法会在等待时解锁Mutex，并在返回时重新锁定。所以，我们的接收函数不会在等待时保持互斥体锁定。\n', '\n', '虽然这个通道在使用上非常灵活，因为它允许任何数量的发送和接收线程，但在许多情况下，其实现可能远非最佳。即使有很多消息已经准备好被接收，任何发送或接收操作都会暂时阻止任何其他发送或接收操作，因为它们都必须锁定同一互斥体。如果VecDeque::push需要扩展VecDeque的容量，所有发送和接收线程都需要等待那个线程完成重新分配，这在某些情况下可能是不可接受的。\n', '\n', '其他一个可能不被期望的属性是该通道的队列可能无限制地增长。没有什么可以阻止发送者以比接收者处理它们更高的速度连续发送新消息。', '\n', '一个不安全的单次通道\n', '\n', '通道的各种用例几乎无穷无尽。然而，在这一章的剩余部分，我们将专注于一种特定类型的用例：从一个线程向另一个线程发送一个消息。这种用例通常被称为单次通道。\n', '\n', '我们可以取上面基于Mutex<VecDeque>的实现，并将VecDeque替换为Option，有效地将队列的容量减少到一个消息。这样就能避免分配，但是依然存在一些使用Mutex的缺点。我们可以通过使用原子来建立我们自己的一个单次通道来避免这个问题。\n', '\n', '首先，让我们构建一个单次通道的最小实现，暂时不考虑它的接口。后面的这一章，我们将探索改进它的方式，并如何与Rust的类型系统一起协作，为我们的通道提供好的体验。\n', '\n', '我们开始的工具基本上与我们用于SpinLock<T>（来自第4章）相同：一个用于存储的UnsafeCell和一个AtomicBool来指示其状态。在这里，我们使用原子布尔值来表示消息是否已准备好消费。\n', '\n', '在发送一条消息之前，通道是"空的"，还没有为类型T添加任何消息。我们可以在单元格内使用Option<T>安排T的缺席。然而，这可能会浪费宝贵的内存空间，因为我们的原子布尔值已经告诉我们是否有一条信息。相反，我们可以使用std::mem::MaybeUninit<T>，它本质上是Option<T>的不安全版本：它要求使用者手动跟踪它是否已经初始化，并且几乎整个接口都是不安全的，因为它不能执行它自己的检查。\n', '\n', '把这一切放在一起，我们以这个结构体定义开始我们的第一次尝试：\n', '\n', 'use std::mem::MaybeUninit;\n', '\n', 'pub结构体Channel<T> {\n', '    message：UnsafeCell<MaybeUninit<T>>，\n', '    ready：AtomicBool，\n', '}\n', '\n', '就像我们的SpinLock<T>，我们需要告诉编译器我们的通道是安全地在线程间共享的，至少只有当T是Send:\n', '\n', 'unsafe impl<T> Sync for Channel<T> where T: Send {}\n', '\n', '一个新的通道是空的，ready设置为false，消息未初始化:\n', '\n', 'impl<T> Channel<T> {\n', '    pub const fn new() -> Self {\n', '        Self {\n', '            message: UnsafeCell::new(MaybeUninit::uninit()),\n', '            ready: AtomicBool::new(false),\n', '        }\n', '    }\n', '\n', '    …\n', '}\n', '\n', '要发送一条消息，首先需要将其存储在单元格中，然后我们可以通过将就绪标志设置为真值来将其发布到接收器。尝试这样做不止一次将是很危险的，因为在设置就绪标志后，接收器可能在任何时刻阅读消息，与第二次尝试发送消息产生冲突。目前，我们让此事成为用户的责任，使方法变得不安全，并留下一条注意事项给他们:\n', '\n', '    /// Safety: Only call this once!\n', '    pub unsafe fn send(&self, message: T) {\n', '        (*self.message.get()).write(message);\n', '        self.ready.store(true, Release);\n', '    }\n']['\n', '在上面的片段中，我们使用UnsafeCell::get方法获取到MaybeUninit<T>的指针，并且不安全地解引用它来调用MaybeUninit::write以初始化它。滥用这一点可能会导致未定义的行为，但我们已经将这个责任吹给了调用方。\n', '\n', '对于内存序，我们需要使用release序，因为原子存储实际上将信息传递给了接收方。这确保了消息的初始化将从接收线程的角度出发，如果它使用acquire序从self.ready加载为真。\n', '\n', '对于接收，我们现在不打算提供阻塞接口。相反，我们将提供两个方法：一个用来检查是否有消息可用，另一个用来接收消息。我们将让我们的通道的用户自行决定是否使用线程挂起（"线程挂起"在第一章中）如果他们想要阻塞。\n', '\n', '这是我们完成这个版本的通道的最后两个方法：\n', '\n', '    pub fn is_ready(&self) -> bool {\n', '        self.ready.load(Acquire)\n', '    }\n', '\n', '    /// Safety: Only call this once,\n', '    /// and only after is_ready() returns true!\n', '    pub unsafe fn receive(&self) -> T {\n', '        (*self.message.get()).assume_init_read()\n', '    }\n', '\n', '虽然is_ready方法可以始终安全地调用，但receive方法使用MaybeUninit::assume_init_read()，这个方法不安全地假设它已经被初始化，并且没有被用来产生非Copy对象的多个副本。就像send一样，我们仅仅让这成为我们用户的问题，让这个功能本身不安全。\n', '\n', '结果是技术上可用的通道，但是很笨拙并且总的来说令人失望。如果握得对，它确切地做了它应该做的，但是有很多微妙的方法可以误用它。\n', '\n', '多次调用send可能会导致数据竞争，因为第二个发送者可能会在接收者试图读取第一条消息的同时重写数据。即使接收被正确地同步，从多个线程调用send可能会导致两个线程试图同时写入cell，也会导致数据竞争。此外，多次调用receive结果在两份消息，即使T没有实现Copy也不能安全地复制。\n', '\n', '一个比较微妙的问题是我们的通道没有Drop实现。MaybeUninit类型不会跟踪是否已经初始化，因此在被放弃时不会自动放弃其内容。这就意味着如果一条消息被发送但从未被接收，消息将永远不会被丢弃。这并不是不健康的，但通常是需要避免的。虽然在Rust中，泄露被普遍认为是安全的，但一般只有作为另一种泄漏的结果才是可接受的。例如，泄露Vec也会泄露其内容，但是Vec的正常使用不会导致任何泄漏。\n', '\n', '由于我们让用户负责所有事情，这只是个时间问题，因为这样最终导致了一场不幸的事故。\n', '通过运行时检查的安全性\n', '\n', '为了提供更安全的接口，我们可以添加一些检查使误用会导致带有清晰信息的恐慌，这比未定义的行为要好得多。\n', '\n', '让我们开始处理在消息准备就绪之前调用receive的问题。这个问题很简单，我们只需要让receive方法在尝试读取消息之前验证ready标志即可：\n', '\n', '    /// Panics if no message is available yet.\n', '    ///\n', '    /// Tip: Use `is_ready` to check first.\n', '    ///\n', '    /// Safety: Only call this once!\n', '    pub unsafe fn receive(&self) -> T {\n', '        if !self.ready.load(Acquire) {\n', '            panic!("no message available!");\n', '        }\n', '        (*self.message.get()).assume_init_read()\n', '    }\n', '\n', '该方法仍然不安全，因为用户仍然负责不多次调用这个函数，但是失败检查is_ready()首先不再导致未定义的行为。\n', '\n', '由于我们现在在receive方法中有一个获取ready标志的必要同步，所以我们可以将is_ready中的加载降低到Relaxed，因为该内存仅用于说明目的：\n', '\n', '    pub fn is_ready(&self) -> bool {\n', '        self.ready.load(Relaxed)\n', '    }\n', '\n', '请记住，就绪状态的总修订顺序（参见第3章中的"Relaxed Ordering"）保证在is_ready从中加载true后，receive也会看到true。没有可能性is_ready返回true并且receive()仍然惊慌无论is_ready中使用的是什么内存排序。
'\n', '下一个要解决的问题是多次调用receive会发生什么。通过在我们的receive方法中将ready标志设置回false，我们可以轻松地使之变为恐慌，像这样：\n', '\n', '    /// Panics if no message is available yet,\n', '    /// or if the message was already consumed.\n', '    ///\n', '    /// Tip: Use `is_ready` to check first.\n', '    pub fn receive(&self) -> T {\n', '        if !self.ready.swap(false, Acquire) {\n', '            panic!("no message available!");\n', '        }\n', "        // Safety: We've just checked (and reset) the ready flag.\n", '        unsafe { (*self.message.get()).assume_init_read() }\n', '    }\n', '\n', '我们只是将load更改为false的swap，突然之间的receive方法在任何条件下都可以安全地调用。该方法不再标记为不安全。而不是让用户负责所有事情，我们现在负责不安全的代码，从而减少了我们用户的压力。\n', '\n', '对于send，事情稍微复杂一些。为防止多个send调用同时访问cell，我们需要知道是否已经有其他send调用开始。ready标志只告诉我们是否有其他send调用已经完成，所以这是不够的。\n', '\n', '让我们添加一个名为in_use的第二个标志，以指示频道是否已经被使用：\n', '\n', 'pub struct Channel<T> {\n', '    message: UnsafeCell<MaybeUninit<T>>,\n', '    in_use: AtomicBool, // New!\n', '    ready: AtomicBool,\n', '}\n', '\n', 'impl<T> Channel<T> {\n', '    pub const fn new() -> Self {\n', '        Self {\n', '            message: UnsafeCell::new(MaybeUninit::uninit()),\n', '            in_use: AtomicBool::new(false), // New!\n', '            ready: AtomicBool::new(false),\n', '        }\n', '    }\n', '\n', '    …\n', '}\n', '\n', '现在我们需要做的就是在send方法中将in_use设置为true，然后在访问cell之前，并且如果它已经被另一个调用设置，则会引发恐慌：\n', '\n', '    /// Panics when trying to send more than one message.\n', '    pub fn send(&self, message: T) {\n', '        if self.in_use.swap(true, Relaxed) {\n', '            panic!("can\'t send more than one message!");\n']['        }\n', '        不安全{ (*self.message.get()).write(message) };\n', '        self.ready.store(true, Release);\n', '    }\n', '\n', '我们可以使用松散的内存排序来进行原子交换操作，因为in_use的总修改顺序（参见第3章的 "Relaxed Ordering"）保证只会有一个在in_use上的交换操作返回false，这是send试图访问cell的唯一情况。\n', '\n', '我们现在有了一个完全安全的接口，但还有一个问题未解决。最后一个问题是，发送一个永远不会被接收的消息：它永远不会被丢弃。虽然这样不会导致未定义的行为，也被允许在安全代码中出现，但这绝对是我们需要避免的。\n', '\n', '因为我们在receive方法中重置了ready标识，所以修复这个问题很容易：ready标识显示是否有一个还未接收的消息在cell中需要被丢弃。\n', '\n', '在我们的Channel的Drop实现中，我们不需要使用原子操作来检查原子ready标识，因为只有当一个对象完全被丢弃它的线程拥有，没有其他未解决的借用时，才可以被丢弃。这意味着我们可以使用AtomicBool::get_mut方法，它需要一个独占引用（&mut self），证明原子访问是不必要的。对于UnsafeCell也适用，通过UnsafeCell::get_mut。\n', '\n', '使用这个方法，这是我们完全安全且无泄漏channel的最后一部分：\n', '\n', 'impl<T> Drop for Channel<T> {\n', '    fn drop(&mut self) {\n', '        if *self.ready.get_mut() {\n', '            不安全 { self.message.get_mut().assume_init_drop() }\n', '        }\n', '    }\n', '}\n', '\n', '我们来试试看！\n', '\n', '由于我们的Channel尚未提供阻塞接口（尚未），因此我们将手动使用线程停车等待消息。收到线程将自行停车（park）只要还没有消息准备好，并且发送线程一旦发送了什么，就会解开（unpark）接收器。\n', '\n', '以下是一个完整的测试程序，从第二个线程通过我们的Channel发送字符串字面量 "hello world!" 返回到主线程：\n', '\n', 'fn main() {\n', '    let channel = Channel::new();\n', '    let t = thread::current();\n', '    thread::scope(|s| {\n', '        s.spawn(|| {\n', '            channel.send("hello world!");\n', '            t.unpark();\n', '        });\n', '        while !channel.is_ready() {\n', '            thread::park();\n', '        }\n', '        assert_eq!(channel.receive(), "hello world!");\n', '    });\n', '}\n', '\n', '这个程序可以编译，运行，并且干净地退出，显示我们的Channel运行正常。\n', '\n', '如果我们复制发送行，我们也可以看到我们的安全检查操作之一正在运行，当程序运行时，它会产生以下的恐慌信息：\n', '\n', "线程 '<unnamed>' 在src/main.rs产生恐慌：\n", "不能再发送超过一条信息！\n", '\n', '虽然一个产生恐慌的程序不好，但它完全面见到恐慌要比面临未定义行为的潜在恐怖得多。\n', '使用一个原子来表示通道状态\n', '\n', '如果你还不能满足于实现频道，这里有一个微妙的变化可以节省一个字节的内存。\n', '\n', '我们不再使用两个独立的原子布尔值来表示通道的状态，而是使用一个单独的AtomicU8来表示所有四种状态。与其原子交换布尔值，不如使用compare_exchange来原子检查频道是否处于预期的状态并改变它的状态。\n', '\n', 'const EMPTY: u8 = 0;\n', 'const WRITING: u8 = 1;\n', 'const READY: u8 = 2;\n', 'const READING: u8 = 3;\n', '\n', 'pub struct Channel<T> {\n', '    message: UnsafeCell<MaybeUninit<T>>,\n', '    state: AtomicU8,\n', '}\n', '\n', 'unsafe impl<T: Send> Sync for Channel<T> {}\n', '\n', 'impl<T> Channel<T> {\n', '    pub const fn new() -> Self {\n', '        Self {\n', '            message: UnsafeCell::new(MaybeUninit::uninit()),\n', '            state: AtomicU8::new(EMPTY),\n', '        }\n', '    }\n', '\n', '    pub fn send(&self, message: T) {\n', '        if self.state.compare_exchange(\n', '            EMPTY, WRITING, Relaxed, Relaxed\n', '        ).is_err() {\n', '            panic!("不能更多地发送一条信息!");\n', '        }\n', '        unsafe { (*self.message.get()).write(message) };\n', '        self.state.store(READY, Release);\n', '    }\n', '\n', '    pub fn is_ready(&self) -> bool {\n', '        self.state.load(Relaxed) == READY\n', '    }\n', '\n', '    pub fn receive(&self) -> T {\n', '        if self.state.compare_exchange(\n', '            READY, READING, Acquire, Relaxed\n', '        ).is_err() {\n', '            panic!("没有可用的信息!");\n', '        }\n', '        unsafe { (*self.message.get()).assume_init_read() }\n', '    }\n']['}\n', '\n', 'impl<T> Drop for Channel<T> {\n', '    fn drop(&mut self) {\n', '        if *self.state.get_mut() == READY {\n', '            unsafe { self.message.get_mut().assume_init_drop() }\n', '        }\n', '    }\n', '}\n', '\n', '通过类型的安全性\n', '\n', '虽然我们成功地保护了我们频道的用户免受未定义行为的影响，但如果他们不小心误用它，仍有可能产生恐慌。理想情况下，编译器会检查正确的用法，并在程序甚至运行之前指出误用的地方。\n', '\n', '让我们来看一下多次调用send或receive的问题。\n', '\n', '为了防止一个函数被调用多次，我们可以让它接受一个按值传递的参数，它--对于非复制类型--将消耗对象。当一个对象被消耗或移动后，它就从调用者那里消失了，防止它被再次使用。\n', '\n', '通过将调用send或receive的能力分别表示为一个独立的（非复制）类型，并在执行操作时消耗该对象，我们可以确保每个操作只发生一次。\n', '\n', '这引导我们到以下的接口设计，其中，一个信道不再由单一的Channel类型表示，而是由一对Sender和Receiver表示，每个都有一个以self为值的方法：\n', '\n', 'pub fn channel<T>() -> (Sender<T>, Receiver<T>) { … }\n', '\n', 'pub struct Sender<T> { … }\n', 'pub struct Receiver<T> { … }\n', '\n', 'impl<T> Sender<T> {\n', '    pub fn send(self, message: T) { … }\n', '}\n', '\n', 'impl<T> Receiver<T> {\n', '    pub fn is_ready(&self) -> bool { … }\n', '    pub fn receive(self) -> T { … }\n', '}\n', '\n', '用户可以通过调用channel()创建一个频道，它将给他们一个Sender和一个Receiver。他们可以自由地传递这些对象，将它们移动到另一个线程等。然而，他们不能得到其中任何一个的多份复制，保证send和receive只能被调用一次。\n', '\n', '为了实现这一点，我们需要找到一个存放我们的UnsafeCell和AtomicBool的地方。以前，我们只有一个包含这些字段的结构，但现在我们有两个独立的结构，每个都可能比另一个存活更久。\n', '\n', '由于发送者和接收者需要共享这些变量的所有权，我们将使用Arc（第1章中的"引用计数"）为我们提供一个带有引用计数的共享分配，其中我们存储共享的Channel对象。如下所示，Channel类型不需要是public的，因为它的存在只是一个对用户无关的实现细节。\n', '\n', 'pub struct Sender<T> {\n', '    channel: Arc<Channel<T>>,\n', '}\n', '\n', 'pub struct Receiver<T> {\n', '    channel: Arc<Channel<T>>,\n', '}\n', '\n', 'struct Channel<T> { // 不再是`pub`\n', '    message: UnsafeCell<MaybeUninit<T>>,\n', '    ready: AtomicBool,\n', '}\n', '\n', 'unsafe impl<T> Sync for Channel<T> where T: Send {}\n', '\n', '就像之前一样，我们在T是Send的情况下为Channel<T>实现Sync，以允许它在多个线程之间使用。\n', '\n', '注意我们不再需要像我们之前的频道实现那样的in_use原子布尔。它只是被send用来检查它是否被调用多次，这现在已经通过类型系统静态地保证了。\n', '\n', '创建频道和发送器-接收器对的channel函数看起来类似于我们之前的Channel::new函数，只不过它将Channel包装在Arc中，并将那个Arc和它的一个克隆包装在Sender和Receiver类型中：\n', '\n', 'pub fn channel<T>() -> (Sender<T>, Receiver<T>) {\n', '    let a = Arc::new(Channel {\n', '        message: UnsafeCell::new(MaybeUninit::uninit()),\n', '        ready: AtomicBool::new(false),\n', '    });\n', '    (Sender { channel: a.clone() }, Receiver { channel: a })\n', '}\n', '\n', 'send、is_ready和receive方法基本上和我们之前实现的一样，只是有几处不同：\n', '\n', '    它们现在被移到了各自的类型中，所以只有（一个单独的）发送者才能发送，只有（一个单独的）接收者才能接收。\n', '\n', '    send和receive现在是以self为值接受，而不是以引用接受，以确保它们各自只能被调用一次。\n', '\n', '    send现在不再可能引发恐慌，因为它的前提条件（只能被调用一次）现在已经通过静态保证了。\n', '\n', '所以，它们现在看起来是这样的：\n', '\n', 'impl<T> Sender<T> {\n', '    /// 这永远不会引发恐慌。:)\n', '    pub fn send(self, message: T) {\n', '        unsafe { (*self.channel.message.get()).write(message) };\n', '        self.channel.ready.store(true, Release);\n', '    }\n', '}\n', '\n', 'impl<T> Receiver<T> {\n', '    pub fn is_ready(&self) -> bool {\n', '        self.channel.ready.load(Relaxed)\n', '    }\n', '\n', '    pub fn receive(self) -> T {\n', '        if !self.channel.ready.swap(false, Acquire) {\n', '            panic!("没有可用的消息！");\n', '        }\n', '        unsafe { (*self.channel.message.get()).assume_init_read() }\n', '    }\n']['}\n', '\n', '接收函数还可能产生恐慌，因为用户可能在is_ready()返回true之前就调用它。它还是使用swap将就绪标志设置回false（而不仅仅是加载），这样Channel的Drop实现就知道是否有一个未读的消息需要被丢弃。', '\n', '刚刚实现的Drop正是我们之前实现的Drop：', '\n', 'impl<T> Drop for Channel<T> {\n', ' fn drop(&mut self) {\n', ' if *self.ready.get_mut() {\n', ' unsafe { self.message.get_mut().assume_init_drop() }\n', ' }\n', ' }\n', '}\n', '\n', 'Arc<Channel<T>>的Drop实现会在Sender<T>或Receiver<T>被丢弃时减小分配的引用计数器。当丢弃第二个时，该计数器达到零，Channel<T>本身被丢弃。这将调用我们上面的Drop实现，在那里如果有一个已发送但未接收的消息，我们可以删除它。', '\n', '让我们试试看：', '\n', 'fn main() {\n', ' thread::scope(|s| {\n', ' let (sender, receiver) = channel();\n', ' let t = thread::current();\n', ' s.spawn(move || {\n', ' sender.send("hello world!");\n', ' t.unpark();\n', ' });\n', ' while !receiver.is_ready() {\n', ' thread::park();\n', ' }\n', ' assert_eq!(receiver.receive(), "hello world!");\n', ' });\n', '}\n', '\n', '我们仍然需要手动使用线程停车等待消息，这有点不方便，但我们会在稍后处理这个问题。', '\n', '我们目前的目标是在编译时至少使一种误用形式不可能。这次不同于上次，试图发送两次不会导致程序恐慌，而是根本不会产生有效程序。如果我们在上面的有效程序中添加另一个发送调用，编译器现在就会捕捉到问题，并耐心地通知我们我们的错误：', '\n', 'error[E0382]: use of moved value: `sender`\n', ' --> src/main.rs\n', ' |\n', ' | sender.send("hello world!");\n', ' | --------------------\n', ' | `sender` moved due to this method call\n', ' |\n', ' | sender.send("second message");\n', ' | ^^^^^^ value used here after move\n', ' |\n', 'note: this function takes ownership of the receiver `self`, which moves `sender`\n', ' --> src/lib.rs\n', ' |\n', ' | pub fn send(self, message: T) {\n', ' | ^^^^\n', ' = note: move occurs because `sender` has type `Sender<&str>`,\n', ' which does not implement the `Copy` trait\n', '\n', '取决于情况，设计一个在编译时捕获错误的接口可能非常棘手。如果情况允许这样的接口，它不仅可以给用户带来更多方便，也可以减少静态保证的事物的运行时检查的数量。例如，我们不再需要in_use标志，也去掉了send方法中的置换和检查。', '\n', '不幸的是，可能会出现新的问题，这可能导致更多的运行时开销。在这种情况下，问题是拆分所有权，我们不得不使用Arc，并付出分配的代价。', '\n', '不得不在安全性、便利性、灵活性、简单性和性能之间进行折衷是不幸的，但有时是无法避免的。Rust通常努力使之容易在所有这些方面都做得很好，但有时会让你牺牲一点来最大化别的。\n', '借用以避免分配\n', '\n', '我们刚刚设计的基于Arc的通道实现非常方便使用——代价是一些性能，因为它必须分配内存。如果我们想优化效率，我们可以牺牲一些便利性以提高性能，让用户负责共享的Channel对象。我们可以让用户创建一个可以被Sender和Receiver借用的Channel，而不是在幕后关心Channel的分配和所有权。这样，他们就可以选择简单地将Channel放在一个本地变量中，避免分配内存的开销。', '\n', '我们还需要牺牲一些简单性，因为我们现在需要处理借用和生命周期。', '\n', '因此，这三种类型现在看起来如下，Channel再次公开，Sender和Receiver借用它一定的生命周期。', '\n', 'pub struct Channel<T> {\n', ' message: UnsafeCell<MaybeUninit<T>>,\n', ' ready: AtomicBool,\n', '}\n', '\n', 'unsafe impl<T> Sync for Channel<T> where T: Send {}\n', '\n', "pub struct Sender<'a, T> {\n", " channel: &'a Channel<T>,\n", '}\n', '\n', "pub struct Receiver<'a, T> {\n", " channel: &'a Channel<T>,\n", '}\n', '\n', '我们不再有一个channel()函数来创建（Sender， Receiver）对，我们回到了本章早些时候的Channel::new，允许用户将这样的对象作为局部变量创建。', '\n', '此外，我们需要一种方法让用户创建一个将借用Channel的Sender和Receiver对象。这需要是一个独占借用（&mut Channel），以确保同一个通道不能有多个发送者或接收者。通过同时提供Sender和Receiver，我们可以将独占借用分解为两个共享借用，这样发送者和接收者都可以引用通道，同时防止任何其他事物触碰通道。', '\n', '这导致了以下实现：', '\n', 'impl<T> Channel<T> {\n', ' pub const fn new() -> Self {\n', ' Self {\n', ' message: UnsafeCell::new(MaybeUninit::uninit()),\n', ' ready: AtomicBool::new(false),\n', ' }\n', ' }\n', '\n', " pub fn split<'a>(&'a mut self) -> (Sender<'a, T>, Receiver<'a, T>) {\n", ' *self = Self::new();\n', ' (Sender { channel: self }, Receiver { channel: self })\n']['    }\n', '}\n', '\n', "split方法有着有些复杂的签名，值得我们仔细研究。它通过一个独占引用来借用self，并将其分裂为两个共享引用（分别包裹在Sender类型和Receiver类型中）。'a生命周期表明这两个对象借用了有限生命周期的东西；在这个例子中，就是Channel本身。由于Channel被独占借用，只要Sender或Receiver对象存在，调用者就无法借用或移动它。\n", '\n', '然而，一旦这两个对象都不再存在，可变借用就过期了，编译器会愉快地允许对Channel对象进行第二次split()调用的借用。虽然我们可以假设当Sender和Receiver仍然存在时，无法再次调用split()，但我们不能阻止在这些对象被删除或忘记后的第二次split()调用。我们需要确保我们不会意外地为一个已经设置了就绪标志的通道创建一个新的Sender或Receiver对象，因为这将打破防止未定义行为的假设。\n", '\n', '通过在split()中用一个新的空通道覆盖*self，我们可以确保在创建Sender和Receiver状态时它处于预期的状态。这也会触发对旧的*self的Drop实现，这将负责丢弃之前发送但未接收的消息。\n', '\n', '由于split的签名中的生命周期来自self，所以上面的代码片段中split的签名能够被省略。签名的更少冗余版本如下：\n', '\n', 'pub fn split(&mut self) -> (Sender<T>, Receiver<T>) { … }\n', '\n', '虽然这个版本并没有明确显示返回的对象借用了self，但编译器仍然会检查生命周期的正确用法，就像它对更冗长版本所做的那样。\n', '\n', "剩下的方法和Drop实现与我们基于Arc的实现相同，只是Sender和Receiver类型增加了一个'_生命期参数。（如果你忘了这些，编译器将提供帮助，建议你添加它们）\n", '\n', '为了完整，这里是剩下的代码：\n', '\n', "impl<T> Sender<'_, T> {\n", '    pub fn send(self, message: T) {\n', '        unsafe { (*self.channel.message.get()).write(message) };\n', '        self.channel.ready.store(true, Release);\n', '    }\n', '}\n', '\n', "impl<T> Receiver<'_, T> {\n", '    pub fn is_ready(&self) -> bool {\n', '        self.channel.ready.load(Relaxed)\n', '    }\n', '\n', '    pub fn receive(self) -> T {\n', '        if !self.channel.ready.swap(false, Acquire) {\n', '            panic!("no message available!");\n', '        }\n', '        unsafe { (*self.channel.message.get()).assume_init_read() }\n', '    }\n', '}\n', '\n', 'impl<T> Drop for Channel<T> {\n', '    fn drop(&mut self) {\n', '        if *self.ready.get_mut() {\n', '            unsafe { self.message.get_mut().assume_init_drop() }\n', '        }\n', '    }\n', '}\n', '\n', '让我们来测试一下!\n', '\n', 'fn main() {\n', '    let mut channel = Channel::new();\n', '    thread::scope(|s| {\n', '        let (sender, receiver) = channel.split();\n', '        let t = thread::current();\n', '        s.spawn(move || {\n', '            sender.send("hello world!");\n', '            t.unpark();\n', '        });\n', '        while !receiver.is_ready() {\n', '            thread::park();\n', '        }\n', '        assert_eq!(receiver.receive(), "hello world!");\n', '    });\n', '}\n', '\n', '与基于Arc的版本相比，不便之处减少得非常小：我们只需要多写一行代码来手动创建Channel对象。但是，注意到通道必须在范围之前创建，以证明其存在将超过发送者和接收者。\n', '\n', '要查看编译器的借用检查器的操作，可以尝试在各个地方添加对channel.split()的第二次调用。你会发现在线程范围内第二次调用它会导致错误，而在范围结束后调用它是可以接受的。甚至在范围开始之前调用split()也是可以的，只要你在范围开始之前停止使用返回的Sender和Receiver即可。\n', '阻塞\n', '\n', '我们最后来处理我们的Channel的最后一个主要不便之处，即缺乏阻塞接口。在我们每次测试通道的新变体时，我们都已经使用了线程停车。将该模式集成到通道本身应该不会太难。\n', '\n', '为了能够唤醒接收者，发送者需要知道哪个线程被唤醒。std::thread::Thread类型代表了一个线程的句柄，这正是我们需要调用unpark()的东西。我们将接收线程的句柄存储在Sender对象内部，如下所示：\n', '\n', 'use std::thread::Thread;\n', '\n', "pub struct Sender<'a, T> {\n", "    channel: &'a Channel<T>,\n", '    receiving_thread: Thread, // 新增加的!\n', '}\n', '\n', '然而，如果Receiver对象在线程之间发送，这个句柄就会引用到错误的线程。Sender将不知道这一点，仍然会引用最初拥有Receiver的线程。\n', '\n', '我们可以通过让Receiver变得更加限制来处理这个问题，不再让它在线程间发送。如第1章的"线程安全：Send 和 Sync"中所讨论的，我们可以使用特殊的PhantomData标记类型为我们的结构体添加这个限制。一个PhantomData<*const ()>能够完成任务，因为一个原始指针，比如*const ()，并没有实现Send：\n', '\n', "pub struct Receiver<'a, T> {\n", "    channel: &'a Channel<T>,\n", '    _no_send: PhantomData<*const ()>, // 新增加的!\n', '}\n', '\n', '接下来，我们需要修改Channel::split方法来填充新的字段，如下所示：\n', '\n', "    pub fn split<'a>(&'a mut self) -> (Sender<'a, T>, Receiver<'a, T>) {\n", '        *self = Self::new();\n', '        (\n', '            Sender {\n', '                channel: self,\n', '                receiving_thread: thread::current(), // 新增加的!\n', '            },\n', '            Receiver {\n']['                频道: 自我,\n', '                _no_send: PhantomData, // 新！\n', '            }\n', '        )\n', '    }\n', '\n', '我们使用当前线程的句柄作为 receiving_thread 字段，因为我们将返回的 Receiver 对象将留在当前线程上。\n', '\n', 'send 方法并没有太大变化，如下所示。我们只需在 receiving_thread 上调用 unpark() 唤醒接收者，以防它正在等待：\n', '\n', "impl<T> Sender<'_, T> {\n", '    pub fn send(self, message: T) {\n', '        unsafe { (*self.channel.message.get()).write(message) };\n', '        self.channel.ready.store(true, Release);\n', '        self.receiving_thread.unpark(); // 新！\n', '    }\n', '}\n', '\n', 'receive 函数经历了一次较大的改变。新版本不会因为还没有消息就 panic，而是使用 thread::park() 耐心等待消息，并尝试再次获取，直到必要时为止。\n', '\n', "impl<T> Receiver<'_, T> {\n", '    pub fn receive(self) -> T {\n', '        while !self.channel.ready.swap(false, Acquire) {\n', '            thread::park();\n', '        }\n', '        unsafe { (*self.channel.message.get()).assume_init_read() }\n', '    }\n', '}\n', '\n', '记住，thread::park() 可能会偶尔返回。 （或者因为我们的 send 方法以外的东西调用了 unpark()。）这意味着，我们不能假设在 park() 返回时已经设置了 ready 标志。所以，我们需要在被 unpark 后使用循环再次检查标志。\n', '\n', 'Channel<T> 结构、其同步实现、其新函数以及其 Drop 实现保持不变。\n', '\n', '让我们来试试看！\n', '\n', 'fn main() {\n', '    let mut channel = Channel::new();\n', '    thread::scope(|s| {\n', '        let (sender, receiver) = channel.split();\n', '        s.spawn(move || {\n', '            sender.send("hello world!");\n', '        });\n', '        assert_eq!(receiver.receive(), "hello world!");\n', '    });\n', '}\n', '\n', '显然，这个 Channel 的使用比上一个更方便，至少在这个简单的测试程序中。为了换取这种便利，我们必须用一些灵活性来换取：只有调用 split() 的线程才可以调用 receive()。如果你交换 send 和 receive 行，这个程序将无法编译。这根据使用情况，可能完全可以，有用，或者非常不方便。\n', '\n', '有许多方法可以解决这个问题，其中许多将使我们有些额外的复杂性，并影响性能。一般来说，我们可以继续探索的变体和权衡的数量几乎是无穷无尽的。\n', '\n', '我们可以很轻松地花费不健康的时间去实现另外二十个一次性通道的变体，每一个都有些微不同的属性，用于每一个可想象的使用场景和更多。虽然这可能听起来很有趣，但我们应该避免掉入这个陷阱，结束这一章，免得事情失控。\n', '总结\n', '\n', '    通道用来在线程之间发送消息。\n', '\n', '    一个简单、灵活但可能效率较低的通道，只需要 Mutex 和 Condvar 就可以轻松实现。\n', '\n', '    一次性通道是一个设计只发送一条消息的通道。\n', '\n', '    MaybeUninit<T> 类型可以用来表示可能尚未初始化的 T。它的接口大部分是不安全的，它的用户需负责跟踪是否已经被初始化，不复制 non-Copy 数据，并在必要时舍弃其内容。\n', '\n', '    不删除对象（也叫做泄漏或忘记）是安全的，但如果没有充分理由，人们通常不提倡这样做。\n', '\n', '    Panicking 是创建安全接口的一种重要工具。\n', '\n', '    通过值获取 non-Copy 对象可以用来防止一些事情被做多次。\n', '\n', '    独占借用和分割借用可以是强制正确性的强大工具。\n', '\n', '    我们可以确保对象保持在同一线程上，通过确保其类型不实现 Send，这可以通过使用 PhantomData 标记类型来实现。\n', '\n', '    每个设计和实现决策都涉及到权衡，最好根据特定的使用情况来做决定。\n', '\n', '    没有使用场景的设计可能会很有趣和有教育意义，但可能会变成一个无休止的任务。 \n']
