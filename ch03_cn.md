['第3章. 内存排序\n', '\n', '在第2章中，我们简单提到了内存排序的概念。在这一章，我们会深入这个主题，并探索所有可用的内存排序选项，最重要的是，何时使用哪一个。\n', '重新排序和优化\n', '\n', '处理器和编译器会采取各种方法，使您的程序运行得更快。例如，一个处理器可能会判断你的程序中两个特定连续指令不会互相影响，而按照更快的顺序执行它们。比如一个指令在从主内存中获取一些数据时短暂地被阻塞，后续的几个指令可能会在第一个指令完成之前被执行并完成，只要这样做不会改变你的程序的行为。同样，一个编译器可能会决定重新排序或改写程序的部分内容，如果认为这样可能会导致执行速度更快。但是，只有在这样做不会改变你的程序的行为时才会这样做。\n', '\n', '让我们看下面的函数作为一个例子：\n', '\n', 'fn f(a: &mut i32, b: &mut i32) {\n', '    *a += 1;\n', '    *b += 1;\n', '    *a += 1;\n', '}\n', '\n', '这里，编译器肯定会明白，这些操作的顺序并不重要，因为在这三个加法操作中间没有任何事情依赖于*a或*b的值。（假设溢出检查被禁用了。）因此，它可能会重新排列第二个和第三个操作，然后将前两个合并为一个加法操作：\n', '\n', 'fn f(a: &mut i32, b: &mut i32) {\n', '    *a += 2;\n', '    *b += 1;\n', '}\n', '\n', '然后，在执行这个已经优化过的编译程序的这个函数时，处理器可能由于各种原因，在第一个加法之前执行第二个加法，可能是因为*b已经在缓存中，而*a需要从主内存中获取。\n', '\n', '无视这些优化，结果依然相同：*a增加了两个单位，*b增加了一个单位。他们增加的顺序对你的程序的其余部分完全不可见。\n', '\n', '验证特定的重新排列或其他优化不会影响你的程序行为的逻辑，并不考虑其他线程。在我们上面的例子中，这是完全可行的，因为唯一的引用（&mut i32）保证了没有其他东西可能访问这些值，使其他线程无关紧要。唯一会产生问题的情况是当在多个线程之间共享数据时。或者说，使用原子操作的时候。这就是我们必须显式地告诉编译器和处理器，他们可以和不可以对我们的原子操作做什么，因为他们通常的逻辑会忽略线程间的交互可能导致对你程序结果的改变。\n', '\n', '有趣的问题是我们如何告诉它们。如果我们想完全地详细说明什么是可以的，什么是不可以的，那么并发编程可能会变得过于冗长和易出错，甚至可能变得依赖特定的架构：\n', '\n', 'let x = a.fetch_add(1,\n', '    亲爱的编译器和处理器，\n', '    随意将这个指令与操作b的操作进行排列，\n', "    但如果有另一个线程同时执行f，\n", "    请不要与操作c的操作进行重新排序！\n", "    此外，处理器，别忘了清空你的存储缓冲器！\n", "    如果b为零，那么没有关系。\n", '    在那种情况下，随意做任何最快的操作。\n', '    谢谢~ <3\n', ');\n', '\n', '相反，我们只能从一小部分选项中选择，这些选项由std::sync::atomic::Ordering枚举表示，每个原子操作都作为一个参数引用。可用选项的集合非常有限，但却被精挑细选以适应大部分使用场景。这种排序非常抽象，不直接反映实际的编译器和处理器机制，例如指令排序。这使得你的并行代码可以独立于架构并且具有未来效果。 它允许在不了解每个现有和未来处理器和编译器版本的详细信息的情况下进行验证。\n', '\n', 'Rust中可用的排序有：\n', '\n', '    松散排序：Ordering::Relaxed\n', '\n', '    发布和获取排序：Ordering::{Release, Acquire, AcqRel}\n', '\n', '    顺序一致排序：Ordering::SeqCst\n', '\n', '在C++中，还有所谓的消费排序，尽管被特意省略了Rust，但仍然值得讨论。\n', '内存模型\n', '\n', '不同的内存排序选项有严格的形式定义，确保我们精确地知道我们可以假设什么，以及编译器编写者需要提供给我们什么样的保证。为了使这个与特定处理器架构的细节分离，内存排序定义为一个抽象的内存模型。\n', '\n', 'Rust的内存模型，主要是从C++复制过来的，与任何现有的处理器架构都不匹配，而是一个用严格规则集合的抽象模型，这些规则试图代表所有现有和未来架构的最大公约数，同时也给编译器分析和优化程序时足够的自由。\n', '\n', '我们已经看到内存模型在"Borrowing and Data Races" 第1章中的作用，我们谈论到了数据竞争导致未定义行为。Rust的内存模型允许并发的原子存储，但是考虑到同一变量的并发非原子存储为数据竞争，导致未定义的行为。\n', '\n', '然而，在大多数处理器架构中，原子存储和普通的非原子存储之间实际上没有区别，我们将在第7章中看到。可以说内存模型比必要的更严格，但是这些严格的规则使得对程序的推理更加容易，无论是对于编译器还是程序员，它们都为未来的发展预留了空间。\n', 'Happens-Before 关系\n', '\n', '内存模型定义操作发生的顺序，是以happens-before关系方式。这意味着作为一个抽象模型，它不谈论机器指令、缓存、缓冲区、时间、指令排序、编译器优化等，但是只定义了一个东西确保发生在另一个东西之前的情况，并使其他所有的顺序保持未定义。\n', '\n', '基本的happens-before规则是，同一个线程中发生的所有事情都是按顺序发生的。如果一个线程正在执行 f(); g();，那么 f() happens-before g().\n', '\n', '然而，在线程之间，happens-before关系只在少数特定情况下发生，例如在启动和结束一个线程、解锁和锁定一个互斥锁、调用和返回一个函数，以及使用非松弛式内存顺序的原子操作。松弛式内存顺序是最基本（和最能提高性能）的内存顺序，本身决不会导致任何跨线程的 happens-before 关系。\n', '\n', '为了探讨这一点，让我们来看一个我们假设 a 和 b 由不同的线程并发执行的例子：\n', '\n', 'static X: AtomicI32 = AtomicI32::new(0);\n', 'static Y: AtomicI32 = AtomicI32::new(0);\n', '\n', 'fn a() {\n', '    X.store(10, Relaxed); 1\n', '    Y.store(20, Relaxed); 2\n', '}\n', '\n', 'fn b() {\n', '    let y = Y.load(Relaxed); 3\n', '    let x = X.load(Relaxed); 4\n', '    println!("{x} {y}");\n', '}\n', '\n', '如上所述，基本的happens-before规则是同一个线程中发生的所有事情都是按顺序发生的。在这个例子中： 1 happens-before 2, 且 3 happens-before 4, 如图3-1所示。由于我们使用了松弛的内存排序，我们的例子中没有别的happens-before关系。\n', '图3-1. 例子代码中原子操作的happens-before关系。图片描述\n', '\n', '如果a或b在其他线程开始前就已经完成，那么输出将是 0 0 或 10 20。如果a和b同时运行，很容易看出如何输出10 0。这一点发生的一个方式是如果操作按这个顺序执行： 3 1 2 4。\n', '\n', '更有趣的是，输出也可以是 0 20，尽管没有可能的全局一致的四个操作的顺序能导致这个结果。当3被执行时，与2没有happens-before关系，这意味着它可以加载0或20。当4被执行时，与1没有happens-before关系，这意味着它可以加载0或10。在这个情况下，输出 0 20 是一个可行的结果。\n', '\n', '需要理解的重要且反直观的是，操作3加载值20不导致发生happens-before与2的关系，尽管该值是由2存储的。当不一定按照全局一致的顺序发生时，我们直觉上对“先发生”的概念就会破产，比如当涉及到指令排序时。\n', '\n', '一个更实际和直观的，但不那么正式的理解方法是，从线程b执行的角度来看，操作1和2可能会出现相反的顺序。\n', '启动和结束\n', '\n', '启动一个线程创建了一个在spawn()调用前后发生的happens-before 关系，以及新线程开始执行。同样的，结束一个线程创建了一个关于结束的线程，并在结束调用后发生的happens-before关系。\n', '\n', '为了证明，以下例子中的断言不可能失败：']['\n', '静态 X: AtomicI32 = AtomicI32::new(0);\n', '\n', 'fn main() {\n', '    X.store(1, Relaxed);\n', '    let t = thread::spawn(f);\n', '    X.store(2, Relaxed);\n', '    t.join().unwrap();\n', '    X.store(3, Relaxed);\n', '}\n', '\n', 'fn f() {\n', '    let x = X.load(Relaxed);\n', '    assert!(x == 1 || x == 2);\n', '}\n', '\n', '由于join和spawn操作形成的发生-先于关系，我们可以确定地知道，从X加载的操作在第一次存储之后，但在最后一次存储之前发生，如图3-2所示。然而，它是否在第二次存储之前或之后观察到值是无法预测的。换句话说，它可以加载1或者2，但不能加载0或3。\n', '图3-2. 示例代码中spawn、join、store和load操作之间的发生-先于关系。图像描述\n', '松散的顺序\n', '\n', '尽管使用松散内存排序的原子操作不提供任何发生-先于关系，但它们确实保证了每个单独的原子变量的全局修改顺序。这意味着对同一个原子变量的所有修改都以每个线程看到的一致的顺序发生。\n', '\n', '为了说明这是什么意思，假设我们有以下例子，a和b由不同的线程同时执行：\n', '\n', '静态 X: AtomicI32 = AtomicI32::new(0);\n', '\n', 'fn a() {\n', '    X.fetch_add(5, Relaxed);\n', '    X.fetch_add(10, Relaxed);\n', '}\n', '\n', 'fn b() {\n', '    let a = X.load(Relaxed);\n', '    let b = X.load(Relaxed);\n', '    let c = X.load(Relaxed);\n', '    let d = X.load(Relaxed);\n', '    println!("{a} {b} {c} {d}");\n', '}\n', '\n', '在本示例中，只有一个线程修改X，这让我们很容易看出X只有一种可能的修改顺序：0→5→15。它从零开始，然后变成五，最后变成十五。线程不能观察到来自X的与此全局修改顺序不一致的任何值。这意味着"0 0 0 0"、"0 0 5 15"和"0 15 15 15"是其他线程中的打印语句可能的一些结果，而"0 5 0 15"或"0 0 10 15"的输出是不可能的。\n', '\n', '即使对一个原子变量有一个以上可能的修改顺序，所有线程也会在一个单独的顺序上达成一致。\n', '\n', '让我们把a函数换成两个独立的函数a1和a2，它们各自被一个单独的线程执行：\n', '\n', 'fn a1() {\n', '    X.fetch_add(5, Relaxed);\n', '}\n', '\n', 'fn a2() {\n', '    X.fetch_add(10, Relaxed);\n', '}\n', '\n', '假设这些是唯一修改X的线程，现在有两种可能的修改顺序：0→5→15或0→10→15，取决于哪一个fetch_add操作首先执行。无论哪种情况，所有线程都观察到相同的顺序。所以，即使我们有数百个其他线程都在运行我们的b()函数，我们知道如果其中一个打印了10，那么顺序必须是0→10→15，他们中没有一个可能打印5。反之亦然。\n', '\n', '在第二章中，我们看到了许多使用例子，其中个别变量的全局修改顺序保证就足够了，使得松散的内存排序足够了。然而，如果我们尝试进行比这些例子更高级的操作，我们很快会发现我们需要比松散的内存排序更强大的东西。['静态 READY: AtomicBool = AtomicBool::new(false);\n', '\n', 'fn 主函数() {\n', '    线程::创建(|| {\n', '        DATA.存储(123, 非严格);\n', '        READY.存储(true, 释放); // 这个存储之前的所有内容..\n', '    });\n', '    而不是 READY.装载(获取) { // .. 在此加载`true`后可见。\n', '        线程::休眠(持续时间::由毫秒产生(100));\n', '        打印!("等待中...");\n', '    }\n', '    打印!("{}", DATA.加载(非严格));\n', '}\n', '\n', '当储存数据的线程完成后，它使用一个释放-存储来把READY标志设置为真。当主线程通过它的获取-加载操作观察到这一点时，这两个操作之间就建立了一个先行发生关系，如图3-3所示。此时，我们可以确定，在对READY进行释放-存储之前发生的所有事情，对于在获取-加载之后发生的所有事情都是可见的。具体来说，当主线程从DATA中加载数据时，我们可以确定它加载的是在后台线程中存储的值。这个程序在最后一行只可能打印出一个结果：123。\n', '图3-3. 示例代码中原子操作之间的先行关系，显示了通过获取和释放操作形成的跨线程关系。图像描述\n', '\n', '如果我们在这个例子中为所有操作都使用了轻松的内存顺序，那么主线程可能已经看到READY翻转为真，然后从DATA中再加载一个零。\n', '\n', '"释放"和"获取"这两个名字基于它们最基本的用例：一个线程通过将某个值原子地存储到一个原子变量中来释放数据，另一个线程通过原子地加载那个值来获取它。这正是我们在另一个线程中解锁(释放)一个互斥器，然后随后锁定(获取)它时发生的情况。\n', '\n', '在我们的例子中，READY标志的先行关系保证了DATA的存储和加载操作不能同时发生。这意味着我们实际上并不需要这些操作是原子的。\n', '\n', '然而，如果我们试图对我们的数据变量使用一个常规的非原子类型，编译器将拒绝我们的程序，因为Rust的类型系统不允许我们在另一个线程在借用它们的时候从一个线程中改变它们。类型系统并不能神奇地理解我们在这里创建的先行关系。需要一些不安全的代码来向编译器承诺，我们已经仔细考虑过这个问题，我们确定我们没有破坏任何规则，如下所示：\n', '\n', '静态 不安全 DATA: u64 = 0;\n', '静态 READY: AtomicBool = AtomicBool::new(false);\n', '\n', 'fn 主函数() {\n', '    线程::创建(|| {\n', '        // 安全：没有其他事物正在访问DATA,\n', "        // 因为我们还没有设置READY标志。\n", '        不安全 { DATA = 123 };\n', '        READY.存储(true, 释放); // .. 此存储之前的所有事物\n', '    });\n', '    !READY.加载(获取) { // .. 这个加载`true`之后可见。\n', '        线程::休眠(持续时间::由毫秒产生(100));\n', '        打印!("等待中...");\n', '    }\n', '    // 安全：没有其他事物正在改变DATA，因为READY已经设置了。\n', '    打印!("{}", 不安全 { DATA });\n', '}\n', '\n', '更正式的表述\n', '\n', '当一个获取-加载操作观察到一个释放-存储操作的结果时，就形成了一个先行关系。但这是什么意思呢？\n', '\n', '想象一下，两个线程都将一个七释放-存储到同一个原子变量中，然后一个第三个线程从那个变量中加载一个七。第三个线程现在有一个先后关系与第一个线程或第二个线程了吗？这取决于它加载的是"哪个七"：来自第一个线程的七，还是来自第二个线程的七。(或者可能是一个无关的七。)这使我们得出结论，即使七等于七，两个线程的两个七之间也有一些不同。\n', '\n', '我们应该怎么考虑这个问题呢？在"轻松排序"一节中，我们谈到了所有修改原子变量的操作的有序列表，即总体修改顺序。即使同一个值多次写入同一个变量，每个操作也代表了该变量总体修改顺序中的一个独立事件。当我们加载一个值时，加载的值匹配了这个每个变量的"时间线"上的一个特定点，告诉我们我们可能与哪个操作同步。\n', '\n', '例如，如果原子的总体修改顺序是\n', '\n', '    初始化为0\n', '\n', '    释放-存储7 (来自线程二)\n', '\n', '    松散-存储6\n', '\n', '    释放-存储7 (来自线程一)\n', '\n', '然后获取-加载7将与第二个事件的释放-存储或最后一个事件的释放-存储同步。然而，如果我们以前(在先前关系的意义上)看到过6，我们知道我们看到的是最后一个7，而不是第一个，这意味着我们现在与线程一有先行关系，而不是与线程二。\n', '\n', '还有一个额外的细节，那就是一个被释放-存储的值可能被任意数量的取-修改和比较-交换操作修改，而仍然导致与读取最终结果的获取-加载形成先行关系。\n', '\n', '例如，想象一个原子变量有以下的总体修改顺序:\n', '\n', '    初始化为0\n', '\n', '    释放-存储7\n', '\n', '    松散-取-加1，将7改为8\n', '\n', '    释放-取-加1，将8改为9\n', '\n', '    释放-存储7\n', '\n', '    松散-交换10，将7变为10\n', '\n', '现在，如果我们从这个变量中获取加载9，我们不仅建立了一个先行关系与第四个操作(存储的这个值)，还与第二个操作(存储了7)建立了先行关系，尽管第三个操作使用了松散的内存排序。\n', '\n', '同样，如果我们从这个变量获取加载10，它是由一个松散的操作写入的，我们仍然与第五个操作(存储了一个7)建立了一个先行关系。因为那只是一个普通的存储操作(而不是取-修改或比较-交换操作)，它中断了链条：我们并没有与任何其他操作建立先行关系。\n', '实例：锁定\n', '\n', '互斥锁是释放和获取顺序的最常见用例(参见第1章中的"锁定：互斥锁和读写锁")。当锁定时，它们使用原子操作来检查它是否被解锁，同时(原子地)将状态改为"已锁定"。当解锁时，它们使用释放排序将状态恢复为"已解锁"。这意味着解锁一个互斥锁和随后锁定它之间将有一个先行关系。\n', '\n', '这里有一个这种模式的演示：\n', '\n', '静态 不安全 数据: 字符串 = 字符串::新建();\n', '静态 LOCKED: AtomicBool = AtomicBool::new(false);\n', '\n', 'fn f() {\n', '    如果 LOCKED.compare_exchange(false, true, Acquire, Relaxed).is_ok() {\n', '        // 安全：我们拿到了唯一的锁，所以没有其他东西是访问数据的。\n', "        不安全 { 数据.push('!') };\n", '        LOCKED.存储(false, Release);\n', '    }\n', '}\n', '\n', 'fn 主函数() {\n']['    thread::scope(|s| {\n', '        对于 _ 在 0..100 {\n', '            s.spawn(f);\n', '        }\n', '    });\n', '}\n', '\n', '正如我们在第2章的"比较和交换操作"中简短地看到的那样，比较和交换操作需要两个内存排序参数：一个是比较成功且发生存储的情况，一个是比较失败且未发生存储的情况。在f中，我们试图将LOCKED从false改为true，并只在成功时访问DATA。因此，我们只关心成功的内存排序。如果compare_exchange操作失败，那一定是因为LOCKED已经被设置为true，在这种情况下，f不会做任何事情。这与普通互斥锁上的try_lock操作相符。\n', '\n', '一个细心的读者可能已经注意到，比较和交换操作也可能是一个交换操作，因为当已经锁定时，将true换成true并不改变代码的正确性：\n', '\n', '// 这也行。\n', '如果 LOCKED.swap(true, Acquire) == false {\n', '    …\n', '}\n', '\n', '多亏了获取和释放内存排序，我们可以肯定地知道没有两个线程可以同时访问DATA。如图3-4所示，任何对DATA的之前的访问都发生在将false存储到LOCKED的后续释放-存储前，这又发生在将该false改为true的下一次获取-比较和交换（或获取-交换）操作前，这又发生在DATA的下一次访问前。\n', '图3-4.锁定例子中，原子操作之间的发生-在-关系，显示了两个线程按序锁定和解锁的情况。图像描述\n', '\n', '在第4章中，我们将把这个概念转化为一个可重用的类型：自旋锁。\n', '示例：通过间接进行懒初始化\n', '\n', '在第2章的"示例：懒一次初始化"中，我们实现了一个全局变量的懒初始化，使用比较和交换操作来处理多个线程同时初始化值的情况。因为值是一个非零的64位整数，所以我们能够使用AtomicU64来存储它，在初始化之前使用零作为占位符。\n', '\n', '对于一个不适合单个原子变量的更大的数据类型，我们需要寻找另一种方法。\n', '\n', '对于这个例子，假设我们要保持非阻塞行为，使线程永远不会等待另一个线程，而是竞争并从第一个完成初始化的线程那里获取值。这意味着我们仍需要能够在单个原子操作中从"未初始化"到"完全初始化"。\n', '\n', '正如软件工程的基本定理告诉我们的，计算机科学中的每个问题都可以通过增加另一层间接性来解决，这个问题也不例外。由于我们无法将数据装入单个原子变量，我们可以改用一个原子变量来存储指向数据的指针。\n', '\n', 'AtomicPtr<T>是*mut T的原子版本：指向T的指针。我们可以使用一个空指针作为初始状态的占位符，使用比较和交换操作将其原子地替换为一个指向新分配的、完全初始化的T的指针，然后可以被其他线程读取。\n', '\n', '由于我们不仅共享包含指针的原子变量，而且还共享它指向的数据，所以我们不能再像在第2章中那样使用松散的内存排序。我们需要确保分配和初始化数据不会与读取数据发生冲突。换句话说，我们需要在存储和加载操作上使用释放和获取排序，以确保编译器和处理器不会通过例如重新排序指针的存储和数据本身的初始化来破坏我们的代码。\n', '\n', '这导致我们有了以下实现，对于一些任意的数据类型叫做Data：\n', '\n', 'use std::sync::atomic::AtomicPtr;\n', '\n', "fn get_data() -> &'static Data {\n", '    静态 PTR: AtomicPtr<Data> = AtomicPtr::new(std::ptr::null_mut());\n', '\n', '    let mut p = PTR.load(Acquire);\n', '\n', '    如果 p.is_null() {\n', '        p = Box::into_raw(Box::new(generate_data()));\n', '        如果让 Err(e) = PTR.compare_exchange(\n', '            std::ptr::null_mut(), p, Release, Acquire\n', '        ) {\n', '            // Safety: p来自Box::into_raw，\n', "            // 并没有和任何其他线程共享。\n", '            drop(unsafe { Box::from_raw(p) });\n', '            p = e;\n', '        }\n', '    }\n', '\n', '    // Safety: p不是空的并指向一个正确初始化的值。\n', '    unsafe { &*p }\n', '}\n', '\n', '如果我们从PTR获得的指针是非空的，我们假设它指向已经初始化的数据，并构造一个指向该数据的引用。\n', '\n', '但如果它仍然是空的，我们则生成新的数据，并使用Box::new将它存储在新的分配中。然后我们将这个Box转换为一个原始指针，使用Box::into_raw，这样我们就可以尝试使用比较和交换操作将它存入PTR。如果有另一个线程赢得了初始化竞赛，compare_exchange会失败，因为PTR不再是空的。如果发生这种情况，我们会将我们的原始指针重新转换为一个Box，使用drop来释放它，避免内存泄漏，并继续使用其他线程存储在PTR中的指针。\n', '\n', '最后一个unsafe block上的安全性注释提出了我们的假设，即它指向的数据已经被初始化。注意这包括了关于事情发生顺序的假设。为了确保我们的假设成立，我们使用释放和获取内存排序来确保初始化数据真的发生在对其创建引用之前。\n', '\n', '我们在两个地方加载一个可能非空（即，已初始化）的指针：通过加载操作和通过比较和交换操作失败。所以，如上面解释的那样，我们需要在加载内存排序和比较和交换失败内存排序的两者上使用Acquire，以便与存储指针的操作同步。这个存储发生在比较和交换操作成功时，所以我们必须使用Release作为它的成功排序。\n', '\n', '图3-5显示了三个线程调用get_data()时的操作和发生-之前的关系的可视化。在这种情况下，线程A和B都观察到空指针，都试图初始化原子指针。线程A赢得了竞赛，导致线程B的比较和交换操作失败。线程C在线程A将其初始化后才观察到原子指针。最后的结果是，所有三个线程都结束使用线程A分配的盒子。\n', '图3-5.三个线程调用get_data的操作和发生-之前的关系。图像描述\n', 'Consume Ordering\n', '\n', '让我们更详细地看看我们最后一个例子中的内存排序。如果我们把严格的内存模型放在一边，用更实际的方式来思考，我们可以说，释放顺序阻止了数据的初始化与共享指针的存储操作被重新排序。这很重要，因为否则，其他线程可能会在数据完全初始化之前就能看到数据。\n', '\n', '同样，我们可以解释获取序是阻止重排序，这将导致数据在指针加载之前被访问。然而，一个人可能会合理地怀疑，这在实践中是否有任何意义。在已知地址之前，如何能访问到数据呢？我们可能会得出结论，比获取排序稍弱的东西可能就足够了。我们会是对的：这种更弱的排序被称为消耗排序。\n', '\n', '消耗排序基本上是获取排序的轻量级更高效的变体，它的同步效果仅限于依赖于加载值的事物。\n', '\n', '这意味着，如果你消耗加载了一个原子变量中的释放存储值x，那么，基本上，那个存储发生在依赖表达式的计算之前，如*x、array[x]或table.lookup(x + 1)，但不一定在不需要x值的另一个变量的读取之前。\n', '\n', '现在有好消息和坏消息。\n', '\n', '好消息是，在所有现代处理器架构中，消耗排序与松散排序使用的指令完全相同。换句话说，消耗排序可以是"免费的"，而这在某些平台上，获取排序就不是这样。\n', '\n', '坏消息是，没有编译器实际实现消耗排序。\n', '\n', '事实证明，不仅"依赖"计算的概念难以定义，而且在转换和优化程序时保持这样的依赖性更是难上加难。例如，编译器可能能够优化x + 2 - x为只有2，有效地消除了对x的依赖关系。更实际的表达式，如array[x]，如果编译器能够对x可能的值或数组的元素做出任何逻辑推断，就会发生更微妙的变化。如果考虑到控制流，如if语句或函数调用，问题会变得更加复杂。\n', '\n', '因为这个原因，编译器将消耗排序升级为获取排序，以确保安全。C++20标准甚至明确地不鼓励使用消耗排序，指出除了获取排序之外的其它实现方法已经被证明是不可行的。\n', '\n', '有可能在未来找到一个可行的消耗排序的定义和实现。然而，直到那时，Rust并未暴露Ordering::Consume。\n', '顺序一致排序\n', '\n', '最强的内存排序是顺序一致排序：Ordering::SeqCst。它包括所有获取排序（对于加载）和释放排序（对于存储）的保证，并且保证操作的全球一致的顺序。\n', '\n', '这意味着一个程序中使用SeqCst排序的每一个单独的操作都是所有线程都认可的单一总顺序的一部分。这个总顺序与每个单个变量的总修改顺序一致。\n', '\n', '由于它比获取和释放内存排序更强，所以顺序一致的加载或存储可以代替释放-获取对中的获取-加载或释放-存储，构成发生-在前关系。换句话说，获取-加载不仅可以与释放-存储形成发生-在前关系，也可以与顺序一致的存储形成发生-在前关系，同样也可以反过来。\n', '\n', '只有当发生-在前关系的两侧都使用SeqCst排序时，才保证它与SeqCst操作的单一总顺序一致。\n', '\n']
['虽然它可能看起来是最容易理解的内存顺序，但实际上，SeqCst顺序几乎从不必要。在几乎所有情况下，常规的获取和释放顺序就足够了。\n', '\n', '以下是一个依赖于顺序一致性有序操作的例子：\n', '\n', 'use std::sync::atomic::Ordering::SeqCst;\n', '\n', 'static A: AtomicBool = AtomicBool::new(false);\n', 'static B: AtomicBool = AtomicBool::new(false);\n', '\n', 'static mut S: String = String::new();\n', '\n', 'fn main() {\n', '    let a = thread::spawn(|| {\n', '        A.store(true, SeqCst);\n', '        if !B.load(SeqCst) {\n', "            unsafe { S.push('!') };\n", '        }\n', '    });\n', '\n', '    let b = thread::spawn(|| {\n', '        B.store(true, SeqCst);\n', '        if !A.load(SeqCst) {\n', "            unsafe { S.push('!') };\n", '        }\n', '    });\n', '\n', '    a.join().unwrap();\n', '    b.join().unwrap();\n', '}\n', '\n', '这两个线程首先将它们自己的原子布尔值设置为true，以警告另一个线程他们即将访问S，并检查另一个原子布尔值以查看他们是否可以在不引起数据竞争的情况下安全地访问S。\n', '\n', '如果两个存储操作都发生在任一加载操作之前，那么有可能两个线程都不会访问S。然而，由于顺序一致的顺序保证只有其中一个线程能赢得竞争，因此两个线程都无法访问S并引起未定义的行为。在每一个可能的单个总顺序中，第一个操作将是一个存储操作，这阻止了另一个线程访问S。\n', '\n', '实际上，所有的SeqCst使用都涉及到一个模式，即在同一线程上首先全局可见的存储操作必须在后续的加载操作之前。对于这些情况，一种可能更有效的替代方案是使用松散的操作结合SeqCst围栏，我们接下来将探讨这个问题。\n', 'Fences\n', '\n', '除了对原子变量的操作外，我们还可以对一个内存顺序应用一个更多的东西：原子围栏。\n', '\n', 'std::sync::atomic::fence函数代表一个原子围栏，可能是一个释放围栏（Release），获取围栏（Acquire）或两者都有（AcqRel或SeqCst）。一个SeqCst围栏还参与了顺序一致的总顺序。\n', '\n', '原子围栏使你能从原子操作中分离出内存顺序。如果你想将一种内存顺序应用到多个操作，或者只想有条件地应用它，这可能非常有用。\n', '\n', '实质上，一个释放存储可以被分成一个释放围栏和一个（松散的）存储，一个获取加载可以被分成一个（松散的）加载和一个获取围栏：\n', '\n', '释放获取关系的存储，\n', '\n', '    a.store(1, Release);\n', '\n', '可以被一个释放围栏和一个松散的存储代替：\n', '\n', '    fence(Release);\n', '    a.store(1, Relaxed);\n', '\n', '\t\n', '\n', '释放获取关系的加载，\n', '\n', '    a.load(Acquire);\n', '\n', '可以被一个松散的加载和一个获取围栏代替：\n', '\n', '    a.load(Relaxed);\n', '    fence(Acquire);\n', '\n', '使用一个独立的围栏可能会产生一个额外的处理器指令，这可能会稍微降低效率。\n', '\n', '更重要的是，与释放存储或获取加载不同，围栏不是绑定到任何单一的原子变量。这意味着单个的围栏可以同时用于多个变量。\n', '\n', '正式地说，如果一个释放围栏后跟随的（在同一线程中）任何原子操作存储由我们需要同步的获取操作观察到的值，那么释放围栏可以代替发生之前关系中的一个释放操作。同样，如果一个获取围栏前面（在同一线程中）的任何原子操作加载由释放操作存储的值，那么获取围栏可以代替任何一个获取操作。\n', '\n', '将这个结合起来，意味着一个发生之前关系是在一个释放围栏和一个获取围栏之间创建，如果释放围栏后的任何存储被获取围栏前的任何加载观察到。\n', '\n', '例如，假设我们有一个线程执行一个释放围栏，然后对不同的变量执行三个原子存储操作，另一个线程从这些相同的变量中执行三个加载操作，然后执行一个获取围栏，如下：\n', '\n', '线程1：\n', '\n', 'fence(Release);\n', 'A.store(1, Relaxed);\n', 'B.store(2, Relaxed);\n', 'C.store(3, Relaxed);\n', '\n', '\t\n', '\n', '线程2：\n', '\n', 'A.load(Relaxed);\n', 'B.load(Relaxed);\n', 'C.load(Relaxed);\n', 'fence(Acquire);\n', '\n', '在这种情况下，如果线程2的任何加载操作从线程1的对应存储操作加载值，那么线程1的释放围栏在线程2的获取围栏之前发生。\n', '\n', '围栏不需要直接前面或后面是原子操作。在中间可以发生其他任何事情，包括控制流。这可以用来让围栏有条件的，类似于比较和交换操作有成功和失败的顺序。\n', '\n', '例如，如果我们从一个使用获取内存顺序的原子变量加载一个指针，我们可以使用围栏只在指针不为空时应用获取顺序：\n', '\n', '使用一个获取加载：\n', '\n', 'let p = PTR.load(Acquire);\n']['如果 p.is_null() {\n', '    println!("没有数据");\n', '} 否则 {\n', '    println!("数据 = {}", 不安全 { *p });\n', '}\n', '\n', '\t\n', '\n', '使用条件获取围栏:\n', '\n', '让 p = PTR.load(Relaxed);\n', '如果 p.is_null() {\n', '    println!("没有数据");\n', '} 否则 {\n', '    fence(Acquire);\n', '    println!("数据 = {}", 不安全 { *p });\n', '}\n', '\n', '如果预计指针经常为空，这可能有益，以避免在不必要时获取内存顺序。\n', '\n', '让我们看一下使用释放和获取围栏的更复杂的用例:\n', '\n', '使用 std::sync::atomic::fence;\n', '\n', '静态不安全 DATA: [u64; 10] = [0; 10];\n', '\n', '静态 ATOMIC_FALSE: AtomicBool = AtomicBool::new(false);\n', '静态 READY: [AtomicBool; 10] = [ATOMIC_FALSE; 10];\n', '\n', 'fn main() {\n', '    for i in 0..10 {\n', '        thread::spawn(move || {\n', '            let data = some_calculation(i);\n', '            不安全 { DATA[i] = data };\n', '            READY[i].store(true, Release);\n', '        });\n', '    }\n', '    thread::sleep(Duration::from_millis(500));\n', '    let ready: [bool; 10] = std::array::from_fn(|i| READY[i].load(Relaxed));\n', '    如果 ready.contains(&true) {\n', '        fence(Acquire);\n', '        for i in 0..10 {\n', '            如果 ready[i] {\n', '                println!("data{i} = {}", 不安全 { DATA[i] });\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', 'std::array::from_fn 是一个简单的方法，可以执行特定数量的次数并将结果收集到数组中。\n', '\n', '在这个例子中，10个线程做一些计算并将结果存储在（非原子的）共享变量中。每个线程设置一个原子布尔值来指示数据已经准备好由主线程读取，使用普通的释放存储。主线程等待半秒钟，检查所有10个布尔值以查看哪些线程已完成，并打印任何准备好的结果。\n', '\n', '而不是使用10个获取加载操作来读取布尔值，主线程使用松弛操作和一个单一的获取围栏。它在读取数据之前执行围栏，但只有在有数据要读取时才执行。\n', '\n', '虽然在这个特定的例子中，可能完全不必对这样的优化付出任何努力，但这种用于节省额外获取操作开销的模式在构建高效并发数据结构时可能很重要。\n', '\n', 'SeqCst围栏既是一个释放围栏也是一个获取围栏（就像AcqRel一样），但也是顺序一致操作的单一总顺序的一部分。然而，只有围栏是总顺序的一部分，但并不一定是之前或之后的原子操作。这意味着，与释放或获取操作不同，一个顺序一致的操作不能被分解为一个松散操作和一个内存围栏。\n', '编译器围栏\n', '\n', '除了常规的原子围栏，Rust标准库还提供了一个编译器围栏：std::sync::atomic::compiler_fence。它的签名与我们上面讨论的常规围栏完全相同，但它的效果仅限于编译器。与常规的原子围栏不同，它并不能阻止处理器，例如，重新排序指令。在围栏的绝大多数用例中，编译器围栏并不足够。\n', '\n', '一个可能的用例可能出现在实现Unix信号处理器，或者在嵌入式系统上的中断。这些是可以突然中断一个线程，暂时在同一个处理器核上执行一个无关的函数的机制。因为它发生在同一个处理器核上，处理器可能影响内存排序的通常方式并不适用。（关于这个在第7章中有更多的介绍。）在这种情况下，一个编译器围栏可能就足够了，可能会节省一条指令，希望能增加性能。\n', '\n', '另一个用例涉及到进程范围的内存阻塞。这种技术超出了Rust内存模型的范围，只在一些操作系统上支持：在Linux上通过membarrier系统调用，在Windows上使用FlushProcessWriteBuffers函数。它实际上允许一个线程强制地向所有并发运行的线程注入一个（顺序一致的）原子围栏。这允许我们用一个轻量级的编译器围栏和一个重量级的进程范围阻塞来替换两个匹配的围栏。如果在轻量级围栏一侧的代码执行得更频繁，这可以提高整体性能。（有关更多详细信息和在Rust中使用这种阻塞的跨平台方式，请参阅crates.io上的membarrier包的文档。）\n', '\n', '编译器围栏也可以是一种有趣的工具，用于探索处理器对内存排序的影响。在第7章的"试验"中，我们会故意使用编译器围栏替换普通的围栏来破坏我们的代码。这将让我们体验到错误的内存排序可能带来的微妙但可能是灾难性的处理器效果。\n', '常见的误解\n', '\n', '关于内存排序，有很多误解。在我们结束这一章之前，让我们来看一下最常见的误解。\n', '\n', '神话：我需要强内存顺序来确保改变是"立即"可见的。\n', '\n', '一个常见的误解是，使用一个像Relaxed这样的弱内存顺序意味着一个原子变量的改变可能永远不会到达另一个线程，或者只有在显著延迟之后才会到达。 "松散"这个名字可能让人觉得除非有什么东西迫使硬件的某些部分醒来并做它应该做的事情，否则什么都不会发生。\n', '\n', '实际上，内存模型并没有说任何关于时间的事情。它只定义了某些事情发生的顺序；不是你可能需要等待它们的时间。一个假设的计算机，在这个计算机中，从一个线程获取数据到另一个线程可能需要几年的时间，是完全不可用的，但是可以完全满足内存模型。\n', '\n', '在现实生活中，内存排序是关于如何重新排序指令的事情，这种事情通常发生在纳秒级的时间范围内。更强的内存排序并不能使你的数据运行得更快；反而可能会使你的程序变慢。\n', '\n', '神话：禁用优化意味着我不需要关心内存顺序。\n', '\n', '编译器和处理器在使事情以我们可能期望的不同顺序发生时都起着作用。禁用编译器优化并不会禁用编译器中的每一种可能的转换，并且不会禁用导致指令重新排序和类似可能的问题行为的处理器功能。\n', '\n', '神话：使用一个不重新排序指令的处理器意味着我不需要关心内存顺序。\n', '\n', '一些简单的处理器，例如在小型微控制器中的那些，只有一个核心，只能同时执行一个指令，所有的指令都按顺序执行。然而，尽管这样的设备上的一个错误的内存排序真正导致实际问题的机会显著降低，但是仍然有可能由于错误的内存顺序，编译器做出无效的假设，破坏你的代码。除此之外，即使当处理器并不乱序执行指令，它可能仍然有其他可以与内存排序相关的功能。\n', '\n', '神话：松散操作是免费的。\n', '\n', '这是否正确取决于你对"免费"的定义。的确，Relaxed是最高效的内存排序，它可以比其他的快很多。现代平台上，松散的加载和存储操作编译成与非原子读和写相同的处理器指令，这甚至都是真的。\n', '\n', '如果一个原子变量只被一个线程使用，与一个非原子变量的速度差异很可能是因为编译器有更多的自由度，并且在优化非原子操作时更有效。（编译器倾向于避免对原子变量进行大多数类型的优化。）\n', '\n', '然而，从多个线程访问相同的内存通常比从一个单独的线程访问它要慢得多。一个线程，如果它连续地写入一个原子变量，当其他线程开始反复读取这个变量时，可能会体验到一个明显的减速，因为处理器核心和它们的缓存现在必须开始协同工作。\n', '\n', '我们将在第7章中探讨这种效果。\n', '\n', '神话：顺序一致的内存顺序是一个很好的默认值，总是正确的。\n', '\n', '把性能问题放在一边，顺序一致的内存顺序通常被看作是默认的内存顺序类型，因为它的强大的保证。如果任何其他的内存顺序是正确的，SeqCst也是正确的。这可能让人觉得SeqCst总是正确的。然而，一个并发算法可能简单地是不正确的，而无论内存顺序如何。\n']['\n', '更重要的是，在阅读代码时，SeqCst基本上告诉读者：“这个操作依赖于程序中每一个SeqCst操作的总体顺序”，这是一个非常深远的声明。如果使用更弱的内存排序，同样的代码可能更容易复查和验证。例如，Release实质上告诉读者：“这与同一变量上的获取操作有关”，在形成对代码的理解时要考虑的因素要少得多。\n', '\n', '建议将SeqCst视为一个警告标志。在现实中看到它通常意味着正在发生一些复杂的事情，或者可能仅仅是作者没有花时间分析他们的内存排序相关的假设，这两者都是需要额外审查的原因。\n', '\n', '谣言：顺序一致的内存排序可以用于"释放-加载"或"获取-存储"。\n', '\n', '虽然SeqCst可以代表获取或释放，但它不是以某种方式创建一个获取-存储或释放-加载的方法。后者仍然不存在。Release只适用于存储操作，Acquire只适用于加载操作。\n', '\n', '例如，释放存储并没有与SeqCst存储形成任何释放-获取的关系。如果您需要他们成为全局一致顺序的一部分，那么这两个操作必须使用SeqCst。\n', '总结\n', '\n', '可能并不存在所有原子操作的全局一致顺序，因为不同线程可以看到的发生顺序可能不同。\n', '\n', '然而，每个独立的原子变量都有自己的总体修改顺序，无论内存排序如何，所有线程都赞同这一点。\n', '\n', '操作的顺序正式定义为发生在..之前的关系。\n', '\n', '在单个线程内，存在着每个操作之间的发生在..之前的关系。\n', '\n', '产生线程发生在..之前的关系是该线程所做的所有事情。\n', '\n', '一个线程的所有行为发生在..之前的关系是该线程的加入。\n', '\n', '解锁一个互斥体发生在..之前的关系是再次锁定该互斥体。\n', '\n', '从解锁存储中获取加载的值，建立了一个发生在..之前的关系。这个值可能会被任意数量的抓取和修改以及比较和交换操作所修改。\n', '\n', '消耗加载如果存在的话，则是获取加载的一个轻量级版本。\n', '\n', '顺序一致的排序会产生全局一致的操作顺序，但几乎不是必需的，可能会使代码复查更复杂。\n', '\n', '屏障可以让您结合多个操作的内存排序或有条件地应用内存排序规则。\n']