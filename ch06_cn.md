['第6章. 构建我们自己的"Arc"\n', '\n', '在第一章的"引用计数"中，我们看到了std::sync::Arc<T>类型，这个类型通过引用计数允许共享所有权。Arc::new函数会像Box::new一样创建一个新的分配。然而，不同于Box，克隆的Arc会与原始分配共享，不会创建新的分配。只有在Arc和所有其克隆被丢弃后，共享分配才会被丢弃。\n', '\n', '这个类型的实现涉及的内存排序考虑因素可能会非常有趣。在这一章中，我们将更多地把理论用于实践，通过实现我们自己的Arc<T>。我们将从一个基本版本开始，然后扩展它以支持循环结构的弱指针，最后结束本章，用一个优化版本，该版本几乎与标准库中的实现相同。\n', '基本的引用计数\n', '\n', '我们的第一个版本将使用单个AtomicUsize来计算共享一个分配的Arc对象的数量。我们从一个保存这个计数器和T对象的结构体开始:\n', '\n', 'struct ArcData<T> {\n', '    ref_count: AtomicUsize,\n', '    data: T,\n', '}\n', '\n', '注意，这个结构体不是公开的。这是我们Arc实现的内部实现细节。\n', '\n', '接下来是Arc<T>结构体本身，实际上就是一个指向（共享的）ArcData<T>对象的指针。\n', '\n', '可能会有人想把它做成一个Box<ArcData<T>>的包装器，使用标准的Box来处理ArcData<T>的分配。然而，一个Box表示的是独占所有权，而不是共享所有权。我们不能使用引用，因为我们并不只是借用别的东西的数据，而且它的生命周期（“直到最后一个克隆的Arc被丢弃”）并不能直接用Rust的生命周期来表示。\n', '\n', '所以，我们必须使用指针并手动处理分配和所有权的概念。我们将使用std::ptr::NonNull<T>而不是*mut T或*const T，它表示一个指向T的永不为null的指针。这样，一个Option<Arc<T>>的大小将与Arc<T>相同，使用null指针的表示法表示None。\n', '\n', 'use std::ptr::NonNull;\n', '\n', 'pub struct Arc<T> {\n', '    ptr: NonNull<ArcData<T>>,\n', '}\n', '\n', '使用引用或Box时，编译器会自动了解对于结构体应该用哪个T来使其为Send或Sync。然而，使用原始指针或NonNull时，除非我们明确告诉它，否则它会保守地假设它永不为Send或Sync。\n', '\n', '发送一个Arc<T>到其他线程会导致一个T对象被共享，这就需要T是Sync。同样，发送一个Arc<T>到其他线程可能会导致另一个线程丢弃那个T，实际上将其转移到其他线程，这就需要T是Send。换句话说，Arc<T>应该是Send，当且仅当T既是Send又是Sync。对于Sync也适用相同的规则，因为一个共享的&Arc<T>可以被克隆成一个新的Arc<T>。\n', '\n', 'unsafe impl<T: Send + Sync> Send for Arc<T> {}\n', 'unsafe impl<T: Send + Sync> Sync for Arc<T> {}\n', '\n', '对于Arc<T>::new，我们需要创建一个带有引用计数为1的ArcData<T>的新分配。我们将使用Box::new来创建一个新的分配，使用Box::leak来放弃这个分配的独占所有权，并使用NonNull::from将其转换为指针：\n', '\n', 'impl<T> Arc<T> {\n', '    pub fn new(data: T) -> Arc<T> {\n', '        Arc {\n', '            ptr: NonNull::from(Box::leak(Box::new(ArcData {\n', '                ref_count: AtomicUsize::new(1),\n', '                data,\n', '            }))),\n', '        }\n', '    }\n', '\n', '    …\n', '}\n', '\n', '我们知道指针只要Arc对象存在，它就会永远指向一个有效的ArcData<T>。然而，这不是编译器知道或为我们检查的事情，所以通过指针访问ArcData需要不安全的代码。我们将添加一个私有的帮助函数，从Arc获取ArcData，因为这是我们需要反复做的事情：\n', '\n', '    fn data(&self) -> &ArcData<T> {\n', '        unsafe { self.ptr.as_ref() }\n', '    }\n', '\n', '使用该函数，我们现在可以实现Deref特性，使我们的Arc<T>透明地表现得像一个对T的引用：\n', '\n', 'impl<T> Deref for Arc<T> {\n', '    type Target = T;\n', '\n', '    fn deref(&self) -> &T {\n', '        &self.data().data\n', '    }\n', '}\n', '\n', '注意，我们没有实现DerefMut。因为一个Arc<T>代表的是共享所有权，我们不能无条件地提供一个&mut T。\n', '\n', '接下来是：Clone的实现。被克隆的Arc将使用同一个指针，在增加引用计数器后：\n', '\n', 'impl<T> Clone for Arc<T> {\n', '    fn clone(&self) -> Self {\n', '        // TODO: Handle overflows.\n', '        self.data().ref_count.fetch_add(1, Relaxed);\n', '        Arc {\n', '            ptr: self.ptr,\n', '        }\n', '    }\n', '}\n', '\n', '我们可以使用Relaxed内存排序来增加引用计数器，因为对其他变量的操作没有必要在这个原子操作之前或之后严格发生。我们在这个操作之前就已经通过原始Arc访问到了包含的T，而且之后（但现在至少通过两个Arc对象）仍然保持不变。\n', '\n', 'Arc需要被克隆很多次，计数器才有可能溢出，但在一个循环中运行std::mem::forget(arc.clone())可以使它发生。我们可以使用第2章的"示例：ID分配"和"示例：无溢出的ID分配"中讨论的任何技术来处理这个问题。\n', '\n', '为了在正常（非溢出）情况下尽可能高效，我们将保留原始的fetch_add，并在接近溢出时中止整个过程：\n', '\n', '        if self.data().ref_count.fetch_add(1, Relaxed) > usize::MAX / 2 {\n', '            std::process::abort();\n', '        }\n', '\n', '中止进程并不是瞬间发生的，有一段时间内其他线程也可以调用Arc::clone，进一步增加引用计数器。因此，只检查usize::MAX - 1是不够的。然而，使用usize::MAX / 2作为限制是有效的：假设每个线程至少占用了内存中的几个字节，那么usize::MAX / 2个线程是不可能同时存在的。\n', '\n', '就像我们在克隆时增加计数器一样，我们需要在丢弃一个Arc时减少计数器。看到计数器从1变为0的线程知道它丢弃了最后一个Arc<T>，并负责丢弃和释放ArcData<T>。\n', '\n', '我们将使用Box::from_raw来重新获得分配的独占所有权，然后使用drop()立即丢弃它：\n', '\n', 'impl<T> Drop for Arc<T> {\n', '    fn drop(&mut self) {\n', '        // TODO: Memory ordering.\n', '        if self.data().ref_count.fetch_sub(1, …) == 1 {\n']['            不安全{\n', 
'                drop(Box::from_raw(self.ptr.as_ptr()));\n', 
'            }\n', 
'        }\n', 
'    }\n', 
'}\n', 
'\n', 
'对于此操作，我们不能使用Relaxed排序，因为我们需要确保在删除数据时没有其他操作在访问这些数据。换句话说，每个前一个Arc克隆的drop都必须在最后的drop前发生。因此，最后的fetch_sub必须与每一个之前的fetch_sub操作建立一个“发生于...之前”的关系，我们可以使用release和acquire排序来完成：例如，将其从二减至一实际上是“释放”数据，而将其从一减至零则是“获取”数据的所有权。\n', 
'\n', 
'我们可以使用AcqRel内存排序来应对这两种情况，但只有将其减到零的最后一步需要Acquire，而其他操作只需要Release。为了提高效率，我们只使用Release进行fetch_sub操作，并仅在必要时单独使用Acquire围栏：\n', 
'\n', 
'        如果self.data().ref_count.fetch_sub(1, Release) == 1 {\n',
'            fence(Acquire);\n', 
'            不安全{\n',
'                drop(Box::from_raw(self.ptr.as_ptr()));\n', 
'            }\n', 
'        }\n', 
'\n', 
'测试它\n', 
'\n', 
'为了测试我们的Arc是否按预期工作，我们可以编写一个单元测试，创建一个包含特殊对象的Arc，当对象被删除时，让我们知道:\n', 
'\n', 
'#[test]\n', 
'fn test() {\n', 
'    静态的NUM_DROPS：AtomicUsize = AtomicUsize::new(0);\n', 
'\n', 
'    构造 DetectDrop;\n', 
'\n', 
'    推行 Drop 对于 DetectDrop {\n', 
'        fn drop(&mut self) {\n', 
'            NUM_DROPS.fetch_add(1, Relaxed);\n', 
'        }\n', 
'    }\n', 
'\n', 
'    // 创建两个共享包含字符串的对象的Arc\n', 
"    // 和 一个DetectDrop, 来侦测它何时被删除。\n", 
'    let x = Arc::new(("hello", DetectDrop));\n', 
'    let y = x.clone();\n', 
'\n', 
'    // 将x发送至另一个线程，并在那里使用它。\n', 
'    let t = std::thread::spawn(move || {\n', 
'        assert_eq!(x.0, "hello");\n', 
'    });\n', 
'\n', 
'    // 同时，y在这里仍然可以使用。\n', 
'    assert_eq!(y.0, "hello");\n', 
'\n', 
'    // 等待线程完成。\n', 
'    t.join().unwrap();\n', 
'\n', 
'    // 一个Arc, x, 现在应该已经丢失了。\n', 
"    // 我们仍然拥有y,所以这个对象现在不应该被删除。\n", 
'    assert_eq!(NUM_DROPS.load(Relaxed), 0);\n', 
'\n', 
'    // 删除剩余的`Arc`。\n', 
'    drop(y);\n', 
'\n', 
'    // 现在`y`也已经丢失了，\n', 
"    // 这个对象应已经被删除。\n", 
'    assert_eq!(NUM_DROPS.load(Relaxed), 1);\n', 
'}\n', 
'\n', 
'这已经通过编译并运行得很好，所以看起来我们的Arc正在如期工作！尽管这是值得鼓励的，但并不能证明实现完全正确。建议使用涉及许多线程的长时间压力测试来增加更多的信心。\n', 
'Miri\n', 
'\n', 
'使用Miri运行测试也非常有用。Miri是一种实验性但非常有用和强大的工具，用于检查不安全的代码是否存在各种形式的未定义的行为。\n', 
'\n', 
'Miri是Rust编译器的中级中间表示的解释器。这意味着它运行您的代码不是通过将其编译为原生的处理器指令，而是在类型和生命周期信息仍然可用时进行解释。因此，Miri运行程序的速度明显慢于编译和正常运行，但是能够检测许多会导致未定义行为的错误。\n', 
'\n', 
'它包括对检测数据竞争的实验性支持，这使得它能够检测内存排序问题.\n', 
'\n', 
'更多详情以及如何使用Miri的指南，可以参见其GitHub页面。\n', 
'突变\n', 
'\n', 
'如前所述，我们不能为我们的Arc实现DerefMut。我们不能无条件地承诺对数据的独占访问（&mut T），因为数据可能通过其他Arc对象访问。\n', 
'\n', 
'然而，我们可以有条件地允许它。我们可以提供一个只有在引用计数为一时才返回&mut T的方法，从而证明没有其他Arc对象可能被用来访问相同的数据。\n', 
'\n', 
'这个函数，我们将其命名为get_mut，需要接受一个&mut Self以确保没有其他事物可以使用这个相同的Arc来访问T。即使只有一个Arc，如果那个Arc仍然可以被共享，那么这也是无意义的。\n', 
'\n', 
'我们需要使用acquire内存排序来确保之前拥有Arc克隆的线程不再访问数据。我们需要与每一个导致引用计数变为一的drop建立一个“发生于...之前”的关系。\n', 
'\n', 
'这只在引用计数实际上为一的情况下有意义。如果数值更高，我们就不提供&mut T，内存排序就无关紧要。所以，我们可以使用relaxed load，然后再进行条件性的acquire围栏，如下所示：\n', 
'\n', 
'    pub fn get_mut(arc: &mut Self) -> Option<&mut T> {\n', 
'        if arc.data().ref_count.load(Relaxed) == 1 {\n', 
'            fence(Acquire);\n', 
'            // 安全隐患：其他什么都不能访问数据，因为\n', 
"            // 只有一个Arc, 我们对它有绝对的访问权。\n", 
'            不安全 { Some(&mut arc.ptr.as_mut().data) }\n', 
'        } else {\n', 
'            None\n', 
'        }\n', 
'    }\n', 
'\n', 
'此函数不接受self参数，而是接受一个常规参数（命名为arc）。这意味着它只能以Arc::get_mut(&mut a)的形式调用，而不能以a.get_mut()的形式调用。对于实现了Deref的类型，这是建议的做法，以避免和底层T上同名方法的冲突。 \n', 
'\n', 
'返回的可变引用隐式地从参数中借用生命周期，这意味着只要返回的&mut T还在，就不能使用原来的Arc，从而能够安全地进行突变。 \n', 
'\n', 
'当&mut T的生命周期结束后，Arc就可以再被使用和与其他线程分享了。人们可能会疑惑我们是否需要考虑之后访问数据的线程的内存排列问题。然而，这是分享Arc（或其新克隆）给另一个线程的机制的责任。（例如，互斥锁，信道，或生成新的线程。）\n']['弱引用\n', '\n', '当表示由多个对象组成的内存结构时，引用计数可以非常有用。例如，树形结构中的每个节点都可以包含到其子节点的Arc。这样，当节点被丢弃时，不再使用的子节点也都（递归地）被丢弃。\n', '\n', '然而，这种方式在循环结构中会失效。如果子节点也包含到其父节点的Arc,那么由于总是有至少一个Arc仍在引用它，所以它们都不会被丢弃。\n', '\n', '标准库的Arc为这个问题提供了解决方案：Weak<T>。一个Weak<T>，也叫做弱指针，行为有点像Arc<T>，但是不会阻止对象被丢弃。一个T可以在几个Arc<T>和Weak<T>对象之间共享，但是当所有Arc<T>对象都不存在时，该T就会被丢弃，不论是否还有 Weak<T>对象存在。\n', '\n', '这意味着Weak<T>可以在没有T的情况下存在，因此无法无条件地提供&T，就像Arc<T>可以做到的那样。然而，要访问由Weak<T>给出的T，可以通过它的upgrade()方法将其升级为Arc<T>。这个方法返回一个Option<Arc<T>>，如果T已经被丢弃，则返回None。\n', '\n', '在基于Arc的结构中，Weak可以用来打破循环。例如，树形结构中的子节点可以使用Weak而不是Arc来作为他们的父节点。然后，通过它的子节点的存在不会阻止父节点的丢弃。\n', '\n', '让我们来实现这个。\n', '\n', '就像之前那样，当Arc对象的数目达到零时，我们可以丢弃包含的T对象。然而，我们不能丢弃和回收ArcData，因为可能仍然有弱指针引用它。只有当最后一个弱指针也不存在时，我们才能丢弃和回收ArcData。\n', '\n', '所以，我们将使用两个计数器：一个用于“引用T的个数”，另一个用于“引用ArcData<T>的个数”。换句话说，第一个计数器与之前的一样：它计数Arc对象，而第二个计数器计数Arc和Weak对象。\n', '\n', '我们还需要一些东西来允许我们在ArcData<T>仍然被弱指针使用时丢弃包含的对象（T）。我们将使用Option<T>，遗弃数据时，我们可以用None，然后用内在可变性(UnsafeCell)将其包装起来("Interior Mutability"in Chapter 1),允许当ArcData<T>不被独占时发生这种情况：\n', '\n', 'struct ArcData<T> {\n', '    /// `Arc`数量。\n', '    data_ref_count: AtomicUsize,\n', '    /// `Arc`和`Weak`的总数。\n', '    alloc_ref_count: AtomicUsize,\n', "    /// 数据。如果只剩下弱指针，则为`None`。\n", '    data: UnsafeCell<Option<T>>,\n', '}\n', '\n', '如果我们将 Weak<T>视为负责维持 ArcData<T>存活的对象，那么将Arc<T>实现为包含Weak<T>的结构体就有道理，因为Arc<T>需要做相同的事情，并且更多。\n', '\n', 'pub struct Arc<T> {\n', '    weak: Weak<T>,\n', '}\n', '\n', 'pub struct Weak<T> {\n', '    ptr: NonNull<ArcData<T>>,\n', '}\n', '\n', 'unsafe impl<T: Sync + Send> Send for Weak<T> {}\n', 'unsafe impl<T: Sync + Send> Sync for Weak<T> {}\n', '\n', '新的函数和之前大致相同，只是这次需要同时初始化两个计数器：\n', '\n', 'impl<T> Arc<T> {\n', '    pub fn new(data: T) -> Arc<T> {\n', '        Arc {\n', '            weak: Weak {\n', '                ptr: NonNull::from(Box::leak(Box::new(ArcData {\n', '                    alloc_ref_count: AtomicUsize::new(1),\n', '                    data_ref_count: AtomicUsize::new(1),\n', '                    data: UnsafeCell::new(Some(data)),\n', '                }))),\n', '            },\n', '        }\n', '    }\n', '\n', '    …\n', '}\n', '\n', '就像之前一样，我们假定ptr字段总是指向一个有效的ArcData<T>。这次，我们将这个假设编码为Weak<T>上的一个私有data()辅助方法：\n', '\n', 'impl<T> Weak<T> {\n', '    fn data(&self) -> &ArcData<T> {\n', '        unsafe { self.ptr.as_ref() }\n', '    }\n', '\n', '    …\n', '}\n', '\n', '在为Arc<T>实现Deref时，我们现在必须使用UnsafeCell::get()来获取单元内容的指针，并在这一步使用不安全的代码来保证这个指针可以在此时安全地共享。我们还需要as_ref().unwrap()来获取Option<T>中的引用。我们不必担心这会触发恐慌，因为Option只会为None当没有Arc对象剩余。\n', '\n', 'impl<T> Deref for Arc<T> {\n', '    type Target = T;\n', '\n', '    fn deref(&self) -> &T {\n', '        let ptr = self.weak.data().data.get();\n', "        // Safety: 由于有一个Arc指向数据，\n", '        // 数据存在并且可以共享。\n', '        unsafe { (*ptr).as_ref().unwrap() }\n', '    }\n', '}\n', '\n', 'Weak<T>的Clone实现相当直接；它与我们之前为Arc<T>的Clone实现几乎相同：\n', '\n', 'impl<T> Clone for Weak<T> {\n', '    fn clone(&self) -> Self {\n', '        if self.data().alloc_ref_count.fetch_add(1, Relaxed) > usize::MAX / 2 {\n', '            std::process::abort();\n', '        }\n', '        Weak { ptr: self.ptr }\n', '    }\n', '}\n', '\n', '在为我们新的Arc<T>实现Clone时，我们需要增加两个计数器。我们将简单地使用self.weak.clone()来复用上面的代码对第一个计数器，所以我们只需要手动增加第二个计数器：\n', '\n', 'impl<T> Clone for Arc<T> {\n', '    fn clone(&self) -> Self {\n', '        let weak = self.weak.clone();\n', '        if weak.data().data_ref_count.fetch_add(1, Relaxed) > usize::MAX / 2 {\n']
['std::process::abort();\n', '}\n', 'Arc { weak }\n', '}\n', '}\n', '\n', '丢弃一个Weak应该减少其计数器的数量，并在计数器从一减到零时丢弃和释放ArcData。这与我们之前Arc的Drop实现完全一样。\n', '\n', 'impl<T> Drop for Weak<T> {\n', 'fn drop(&mut self) {\n', 'if self.data().alloc_ref_count.fetch_sub(1, Release) == 1 {\n', 'fence(Acquire);\n', 'unsafe {\n', 'drop(Box::from_raw(self.ptr.as_ptr()));\n', '}\n', '}\n', '}\n', '}\n', '\n', '丢弃一个Arc应该减少两个计数器的数量。注意，其中一个已经自动得到了处理，因为每个Arc都包含一个Weak，所以丢弃一个Arc也会导致丢弃一个Weak。我们只需要处理另一个计数器:\n', '\n', 'impl<T> Drop for Arc<T> {\n', 'fn drop(&mut self) {\n', 'if self.weak.data().data_ref_count.fetch_sub(1, Release) == 1 {\n', 'fence(Acquire);\n', 'let ptr = self.weak.data().data.get();\n', '// 安全性：数据引用计数为零，\n', '// 所以没有什么会访问它。\n', 'unsafe {\n', '(*ptr) = None;\n', '}\n', '}\n', '}\n', '}\n', '\n', '在Rust中丢弃一个对象时，首先会运行其Drop::drop函数（如果它实现了Drop），然后递归地丢弃所有的字段。\n', '\n', 'get_mut方法中的检查大部分保持不变，除了现在需要考虑弱指针。虽然在检查独占性时，它可能看起来可以忽略弱指针，但是Weak<T>可以随时升级为Arc<T>。所以，get_mut必须检查在它可以给出一个&mut T之前，没有其他的Arc<T>或Weak<T>指针:\n', '\n', 'impl<T> Arc<T> {\n', '…\n', '\n', 'pub fn get_mut(arc: &mut Self) -> Option<&mut T> {\n', 'if arc.weak.data().alloc_ref_count.load(Relaxed) == 1 {\n', 'fence(Acquire);\n', '// 安全性：除了我们独占访问的这个Arc以外，\n', '// 没有其他东西可以访问数据，也没有任何弱指针。\n', 'let arcdata = unsafe { arc.weak.ptr.as_mut() };\n', 'let option = arcdata.data.get_mut();\n', '// 我们知道数据仍然可用，因为我们有一个指向它的Arc，\n', '// 所以这不会引起恐慌。\n', 'let data = option.as_mut().unwrap();\n', 'Some(data)\n', '} else {\n', 'None\n', '}\n', '}\n', '\n', '…\n', '}\n', '\n', '下一步：升级弱指针。只有数据仍然存在时，才可能将Weak升级为Arc。如果只剩下弱指针，那么就没有可以通过Arc共享的数据了。所以，我们必须增加Arc计数器，但只有在它还不是零的时候才能这样做。我们将使用一个比较交换循环（"Compare-and-Exchange Operations"在第2章）来完成这个操作。\n', '\n', '就像以前一样，放松的内存排序对于增加引用计数是可以的。没有其他变量的操作需要在这个原子操作之前或之后严格发生。\n', '\n', 'impl<T> Weak<T> {\n', '…\n', '\n', 'pub fn upgrade(&self) -> Option<Arc<T>> {\n', 'let mut n = self.data().data_ref_count.load(Relaxed);\n', 'loop {\n', 'if n == 0 {\n', 'return None;\n', '}\n', 'assert!(n <= usize::MAX / 2);\n', 'if let Err(e) =\n', 'self.data()\n', '.data_ref_count\n', '.compare_exchange_weak(n, n + 1, Relaxed, Relaxed)\n', '{\n', 'n = e;\n', 'continue;\n', '}\n', 'return Some(Arc { weak: self.clone() });\n', '}\n', '}\n', '}\n', '\n', '相反，从Arc<T>获取Weak<T>要简单得多:\n', '\n', 'impl<T> Arc<T> {\n', '…\n', '\n', 'pub fn downgrade(arc: &Self) -> Weak<T> {\n', 'arc.weak.clone()\n', '}\n', '}\n', '\n', '测试它\n']['\n', '为了快速测试我们的创作，我们将修改我们的先前的单元测试，以使用弱指针并验证它们可以按预期进行升级：\n', '\n', '#[test]\n', 'fn test() {\n', '    static NUM_DROPS: AtomicUsize = AtomicUsize::new(0);\n', '\n', '    struct DetectDrop;\n', '\n', '    impl Drop for DetectDrop {\n', '        fn drop(&mut self) {\n', '            NUM_DROPS.fetch_add(1, Relaxed);\n', '        }\n', '    }\n', '\n', '    // 使用两个弱指针创建一个 Arc。\n', '    let x = Arc::new(("hello", DetectDrop));\n', '    let y = Arc::downgrade(&x);\n', '    let z = Arc::downgrade(&x);\n', '\n', '    let t = std::thread::spawn(move || {\n', '        // 在此之点，弱指针应能够升级。\n', '        let y = y.upgrade().unwrap();\n', '        assert_eq!(y.0, "hello");\n', '    });\n', '    assert_eq!(x.0, "hello");\n', '    t.join().unwrap();\n', '\n', "    // 数据不应该被丢弃，\n", '    // 并且弱指针应该可以升级。\n', '    assert_eq!(NUM_DROPS.load(Relaxed), 0);\n', '    assert!(z.upgrade().is_some());\n', '\n', '    drop(x);\n', '\n', '    // 现在，数据应该被丢弃，\n', '    // 并且弱指针待应该无法再升级。\n', '    assert_eq!(NUM_DROPS.load(Relaxed), 1);\n', '    assert!(z.upgrade().is_none());\n', '}\n', '\n', '这也可以编译并运行，没有问题，这使得我们手工制作的 Arc 实现功能非常实用。\n', '优化\n', '\n', '虽然弱指针可能有用，但是 Arc 类型常常在没有任何弱指针的情况下使用。我们之前的实现方式的一个弊端是，现在克隆和删除一个 Arc 都需要两个原子操作，因为它们必须递增或递减两个计数器。这使得所有的 Arc 用户都需要为弱指针的成本“支付”，即使它们没有使用它们。\n', '\n', '解决方案似乎是分别计数 Arc<T> 和 Weak<T> 指针，但是我们就无法原子地检查这两个计数器是否都为零。为了理解这样的问题，比如我们有一个线程正在执行以下的函数：\n', '\n', 'fn annoying(mut arc: Arc<Something>) {\n', '    loop {\n', '        let weak = Arc::downgrade(&arc);\n', '        drop(arc);\n', '        println!("I have no Arc!"); 1\n', '        arc = weak.upgrade().unwrap();\n', '        drop(weak);\n', '        println!("I have no Weak!"); 2\n', '    }\n', '}\n', '\n', '这个线程在持续地降级和升级一个 Arc，使得它反复地经历在没有持有任何 Arc (1) 的时间，并在它没有任何 Weak (2) 的时间。如果我们检查两个计数器，看看是否还有任何线程在使用分配，这个线程可能能在我们不走运，且在第一次打印语句 (1) 的时候检查 Arc 计数器，然后在第二次打印语句 (2) 的时候检查 Weak 计数器的时候隐藏其存在。\n', '\n', '在我们的最后一次实现中，我们通过每个 Arc 也计数为 Weak 来解决这个问题。解决这个问题的更微妙的方法是要计算所有的 Arc 指针组合起来作为一个单独的 Weak 指针。这样，弱指针计数器 (alloc_ref_count) 在仍至少有一个 Arc 对象存在的情况下，就像在我们之前的实现中一样，永远不会达到零，但克隆一个 Arc 不再需要触摸该计数器。只有在 drop 最后一个 Arc 时才会减少 weak 指针计数器。\n', '\n', '我们试试看。\n', '\n', '这次，我们无法只是实现 Arc<T> 作为 Weak<T> 的包装，所以两者都将包装一个非空指向分配的指针：\n', '\n', 'pub struct Arc<T> {\n', '    ptr: NonNull<ArcData<T>>,\n', '}\n', '\n', 'unsafe impl<T: Sync + Send> Send for Arc<T> {}\n', 'unsafe impl<T: Sync + Send> Sync for Arc<T> {}\n', '\n', 'pub struct Weak<T> {\n', '    ptr: NonNull<ArcData<T>>,\n', '}\n', '\n', 'unsafe impl<T: Sync + Send> Send for Weak<T> {}\n', 'unsafe impl<T: Sync + Send> Sync for Weak<T> {}\n', '\n', '因为我们正在优化我们的实现，通过使用 std::mem::ManuallyDrop<T> 代替 Option<T>，我们同样可以使 ArcData<T> 变得稍微小一些。我们用 Option<T> 来替换 Some(T) 为 None 当 drop 数据时，但我们实际上不需要一个单独的 None 状态来告诉我们数据已经消失，因为 Arc<T> 的存在状态告诉我们。ManuallyDrop<T> 占用的空间与 T 一样，但允许我们在任何位置以额外的调用 ManuallyDrop::drop() 手动 drop 它：\n', '\n', 'use std::mem::ManuallyDrop;\n', '\n', 'struct ArcData<T> {\n', '    /// `Arc`s的数量。\n', '    data_ref_count: AtomicUsize,\n', '    /// `Weak`s的数量，如果有任何 `Arc`s，则加一。\n', '    alloc_ref_count: AtomicUsize,\n', '    /// 数据。及时只剩下弱指针也会被drop。\n', '    data: UnsafeCell<ManuallyDrop<T>>,\n', '}\n', '\n', 'Arc::new 函数几乎不变，像之前一样一次初始化所有计数器，但现在用 ManuallyDrop::new() 代替 Some():\n', '\n', 'impl<T> Arc<T> {\n', '    pub fn new(data: T) -> Arc<T> {\n', '        Arc {\n', '            ptr: NonNull::from(Box::leak(Box::new(ArcData {\n']['                alloc_ref_count: AtomicUsize::new(1),\n', '                data_ref_count: AtomicUsize::new(1),\n', '                data: UnsafeCell::new(ManuallyDrop::new(data)),\n', '            }))),\n', '        }\n', '    }\n', '\n', '    …\n', '}\n', '\n', 'Deref的实现不能再使用Weak类型的私有data方法，所以我们在Arc<T>上添加相同的私有helper函数：\n', '\n', 'impl<T> Arc<T> {\n', '    …\n', '\n', '    fn data(&self) -> &ArcData<T> {\n', '        unsafe { self.ptr.as_ref() }\n', '    }\n', '\n', '    …\n', '}\n', '\n', 'impl<T> Deref for Arc<T> {\n', '    type Target = T;\n', '\n', '    fn deref(&self) -> &T {\n', "        // Safety: 由于存在指向数据的Arc，\n", '        // 数据存在并可能被共享。\n', '        unsafe { &*self.data().data.get() }\n', '    }\n', '}\n', '\n', 'Weak<T>的Clone和Drop实现和我们上次实现完全相同。 下面是完整的实现，包括私有的Weak::data helper函数：\n', '\n', 'impl<T> Weak<T> {\n', '    fn data(&self) -> &ArcData<T> {\n', '        unsafe { self.ptr.as_ref() }\n', '    }\n', '\n', '    …\n', '}\n', '\n', 'impl<T> Clone for Weak<T> {\n', '    fn clone(&self) -> Self {\n', '        if self.data().alloc_ref_count.fetch_add(1, Relaxed) > usize::MAX / 2 {\n', '            std::process::abort();\n', '        }\n', '        Weak { ptr: self.ptr }\n', '    }\n', '}\n', '\n', 'impl<T> Drop for Weak<T> {\n', '    fn drop(&mut self) {\n', '        if self.data().alloc_ref_count.fetch_sub(1, Release) == 1 {\n', '            fence(Acquire);\n', '            unsafe {\n', '                drop(Box::from_raw(self.ptr.as_ptr()));\n', '            }\n', '        }\n', '    }\n', '}\n', '\n', '现在我们来看这种新的优化实现的所有部分-克隆一个Arc<T>现在只需要处理一个计数器：\n', '\n', 'impl<T> Clone for Arc<T> {\n', '    fn clone(&self) -> Self {\n', '        if self.data().data_ref_count.fetch_add(1, Relaxed) > usize::MAX / 2 {\n', '            std::process::abort();\n', '        }\n', '        Arc { ptr: self.ptr }\n', '    }\n', '}\n', '\n', '同样，丢弃一个Arc<T>现在只需要减少一个计数器，除了最后一次丢弃，使得那个计数器从一减到零。在这种情况下，弱指针计数器也需要减少，以便它可以在没有弱指针左时达到零。我们只需简单地创建一个Weak<T>，然后立即丢弃它：\n', '\n', 'impl<T> Drop for Arc<T> {\n', '    fn drop(&mut self) {\n', '        if self.data().data_ref_count.fetch_sub(1, Release) == 1 {\n', '            fence(Acquire);\n', '            // Safety: 数据引用计数器为零，\n', '            // 所以将不再有任何东西访问这个数据。\n', '            unsafe {\n', '                ManuallyDrop::drop(&mut *self.data().data.get());\n', '            }\n', "            // 由于没有 `Arc<T>`，\n", '            // 丢弃代表所有 `Arc<T>`的隐式弱指针。\n', '            drop(Weak { ptr: self.ptr });\n', '        }\n', '    }\n', '}\n', '\n', 'Weak<T>的upgrade方法基本保持不变，只是它不再克隆弱指针，因为它不再需要增加弱指针计数器。升级只有在已经有至少一个Arc<T>指向分配时才成功，这意味着Arcs已经在弱指针计数器中计算过了。\n', '\n', 'impl<T> Weak<T> {\n', '    …\n', '\n', '    pub fn upgrade(&self) -> Option<Arc<T>> {\n', '        let mut n = self.data().data_ref_count.load(Relaxed);\n', '        loop {\n', '            if n == 0 {\n']['                return None;\n', '            }\n', '            assert!(n <= usize::MAX / 2);\n', '            如果 let Err(e) =\n', '                self.data()\n', '                    .data_ref_count\n', '                    .compare_exchange_weak(n, n + 1, Relaxed, Relaxed)\n', '            {\n', '                n = e;\n', '                continue;\n', '            }\n', '            return Some(Arc { ptr: self.ptr });\n', '        }\n', '    }\n', '}\n', '\n', '到目前为止，这个与我们之前的实现的区别非常小。然而，事情变得棘手的是，我们还需要实现最后两个方法：downgrade和get_mut。\n', '\n', '与之前不同，get_mut方法现在需要检查两个计数器是否都设为一，以确定是否只有一个Arc<T>和没有Weak<T>剩下，因为一个弱指针计数器的一个现在可以代表多个Arc<T>指针。读取计数器是两个分开的操作，其发生的时间（稍微）不同，所以我们必须小心不要错过任何同时发生的降级，如我们在"优化"开始时看到的示例情况。\n', '\n', '如果我们首先检查data_ref_count是一，然后我们可能会错过在我们检查其他计数器之前的后续升级()。但是，如果我们首先检查alloc_ref_count是一，那么我们可能会错过在我们检查其他计数器之前的后续降级()。\n', '\n', '解决这个难题的一种方式是通过"锁定"弱指针计数器来暂时阻止downgrade()操作。为此，我们不需要任何像互斥锁这样的东西。我们可以使用一个特殊的值，比如usize::MAX，来表示弱指针计数器的特殊"锁定"状态。它只会被锁定很短的时间，只用来加载其他计数器，所以如果downgrade方法恰好在get_mut的同时运行，那么它可以在解锁之前一直旋转。\n', '\n', '因此，在get_mut中，我们首先需要检查alloc_ref_count是否为一，并同时将其替换为usize::MAX，如果它确实是一。这是compare_exchange的工作。\n', '\n', '然后我们需要检查另一个计数器是否也是一，之后我们可以立即解锁弱指针计数器。如果第二个计数器也是一，我们知道我们对分配和数据有独占访问权限，这样我们就可以返回一个&mut T。\n', '\n', '    pub fn get_mut(arc: &mut Self) -> Option<&mut T> {\n', "        // Acquire matches Weak::drop's Release decrement, to make sure any\n", '        // upgraded pointers are visible in the next data_ref_count.load.\n', '        if arc.data().alloc_ref_count.compare_exchange(\n', '            1, usize::MAX, Acquire, Relaxed\n', '        ).is_err() {\n', '            return None;\n', '        }\n', '        let is_unique = arc.data().data_ref_count.load(Relaxed) == 1;\n', '        // Release matches Acquire increment in `downgrade`, to make sure any\n', "        // changes to the data_ref_count that come after `downgrade` don't\n", '        // change the is_unique result above.\n', '        arc.data().alloc_ref_count.store(1, Release);\n', '        if !is_unique {\n', '            return None;\n', '        }\n', "        // Acquire to match Arc::drop's Release decrement, to make sure nothing\n", '        // else is accessing the data.\n', '        fence(Acquire);\n', '        unsafe { Some(&mut *arc.data().data.get()) }\n', '    }\n', '\n', '如你可能预期的那样，锁定操作（compare_exchange）需要使用Acquire内存排序，解锁操作（store）需要使用Release内存排序。\n', '\n', '如果我们在compare_exchange中使用了Relaxed，那么即使compare_exchange已经确认所有Weak指针已被删除，对data_ref_count的后续加载也可能看不到新值。\n', '\n', '如果我们在store中使用了Relaxed，那么前面的加载可能会观察到一个未来Arc::drop的结果，即使那个Arc仍然可以被降级。\n', '\n', '获取栅栏与之前相同：它与Arc::Drop中的release-decrement操作同步，确保所有通过前面的Arc克隆的访问在新的独占访问之前就已经发生。\n', '\n', '最后一块拼图是downgrade方法，需要检查特殊的usize::MAX值，看看弱指针计数器是否被锁定，如果被锁定，就等待解锁。就像在upgrade实现中一样，我们将使用一个比较和交换循环来在增加计数器之前检查特殊值和溢出：\n', '\n', '    pub fn downgrade(arc: &Self) -> Weak<T> {\n', '        let mut n = arc.data().alloc_ref_count.load(Relaxed);\n', '        loop {\n', '            if n == usize::MAX {\n', '                std::hint::spin_loop();\n', '                n = arc.data().alloc_ref_count.load(Relaxed);\n', '                continue;\n', '            }\n', '            assert!(n <= usize::MAX / 2);\n', "            // Acquire synchronises with get_mut's release-store.\n", '            if let Err(e) =\n', '                arc.data()\n', '                    .alloc_ref_count\n', '                    .compare_exchange_weak(n, n + 1, Acquire, Relaxed)\n', '            {\n', '                n = e;\n', '                continue;\n', '            }\n', '            return Weak { ptr: arc.ptr };\n', '        }\n', '    }\n', '\n', '我们对compare_exchange_weak使用了acquire内存排序，它与get_mut函数中的release-store同步。否则，对Arc::drop的后续效果可能在它解锁计数器之前对运行get_mut的线程可见。\n', '\n', '换句话说，这里的acquire比较和交换操作有效地"锁定"了get_mut，防止了它的成功。它可以通过后面的Weak::drop将计数器减小到一，使用release内存排序来再次"解锁"。\n', '\n', '我们刚刚完成的Arc<T>和Weak<T>的优化实现与Rust标准库中包含的实现几乎相同。\n', '\n', '如果我们运行与之前完全相同的测试（"Testing It"），我们会看到这个优化的实现也编译并通过了我们的测试。\n', '\n', '如果你觉得为这个优化实现做出正确的内存排序决策很困难，不用担心。许多并行数据结构比这个更简单就能正确实现。本章包含了这个Arc实现，专门针对其关于内存排序的微妙注意事项。\n', '总结\n', '\n', '    Arc<T>提供了一个对引用计数分配的共享所有权。\n', '\n', '    通过检查引用计数器是否完全为一，一个Arc<T>可以有条件地提供独占访问（&mut T）。\n', '\n', '    增加原子引用计数器可以使用relaxed操作，但最后的递减必须与所有以前的递减同步。\n', '\n', '    弱指针（Weak<T>）可以用来避免循环。\n']['\n', '    NonNull<T>类型代表一个永不为空的指向T的指针。\n', '\n', '    ManuallyDrop<T>类型可以用来手动决定，在使用不安全的代码时，何时丢弃一个T。\n', '\n', '    一旦涉及到多个原子变量，事情就会变得更加复杂。\n', '\n', '    实现一个特设的（旋转）锁有时可以作为一种操作多个原子变量的有效策略。\n']